00001048 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 19/05/2023 21:13:04

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : PRAFIN23
00000000                             3  * Written by : <nombres completos de los autores>
00000000                             4  * Date       : 19/05/2023
00000000                             5  * Description: Emulador de la HAL9000
00000000                             6  
00000000                             7  * Dudas = 
00000000                             8  * -(instrucciones ADD) cuando coges un reg y lo sumas
00000000                             9  *   hay que hacer (A1) o A1
00000000                            10  * - instrucciones LOIP y STIP  ¿Xb <-- [Xb] + 1? ¿es pila?
00000000                            11  * - Diferencia entre SET y ADQ solo move en vez de add? 
00000000                            12  *-----------------------------------------------------------
00001000                            13      ORG $1000
00001000= E082 E09B E0B4 E...       14  EMEM:   DC.W $E082,$E09B,$E0B4,$E01D,$2020,$C006,$2031,$C017,$F160
00001012= F170 CE70 3040 E...       15          DC.W $F170,$CE70,$3040,$EFFD,$501E,$4008,$8000,$0001
00001022= 0001 0001 0001 0...       16          DC.W $0001,$0001,$0001,$0001,$0001,$0000,$0000,$0000
00001032= 0000                      17  EIR:    DC.W 0 ;eregistro de instruccion
00001034= 0000                      18  EPC:    DC.W 0 ;econtador de programa
00001036= 0000                      19  ET0:    DC.W 0 ;eregistro T0
00001038= 0000                      20  ET1:    DC.W 0 ;eregistro T1
0000103A= 0000                      21  EX2:    DC.W 0 ;eregistro X2
0000103C= 0000                      22  EX3:    DC.W 0 ;eregistro X3
0000103E= 0000                      23  EX4:    DC.W 0 ;eregistro X4
00001040= 0000                      24  EX5:    DC.W 0 ;eregistro X5
00001042= 0000                      25  EX6:    DC.W 0 ;eregistro X6
00001044= 0000                      26  EX7:    DC.W 0 ;eregistro X7
00001046= 0000                      27  ESR:    DC.W 0 ;eregistro de estado (00000000 00000CNZ)
00001048                            28  START:
00001048  4278 1034                 29      CLR.W EPC
0000104C                            30  
0000104C                            31  FETCH:
0000104C                            32      ;--- IFETCH: INICIO FETCH
0000104C                            33          ;*** En esta seccion debeis introducir el codigo necesario para cargar
0000104C                            34          ;*** en el EIR la siguiente instruccion a ejecutar, indicada por el EPC,
0000104C                            35          ;*** y dejar listo el EPC para que apunte a la siguiente instruccion
0000104C                            36      
0000104C                            37              ; ESCRIBID VUESTRO CODIGO AQUI      
0000104C                            38          
0000104C  3038 1034                 39      MOVE.W EPC,D0           ; movemos el contador a D0
00001050  C0FC 0002                 40      MULU.W #2,D0            ; multiplicamos x2 D0
00001054                            41      
00001054  41F8 1000                 42      LEA.L EMEM,A0           ; cogemos la dirección de la memoria
00001058  D0C0                      43      ADD.W D0,A0             ; sumamos D0 (PC) a A0 para tener la dirección de
0000105A                            44                                  ; la instrucción a ejecutar
0000105A                            45      
0000105A  5278 1034                 46      ADD.W #1,EPC            ; sumamos 1 al EPC para ya apuntar a la siguiente
0000105E  31D0 1032                 47      MOVE.W (A0),EIR         ; movemos la instrucción al eregistro
00001062                            48                                  ; de instrucción
00001062                            49      
00001062                            50          
00001062                            51      ;--- FFETCH: FIN FETCH
00001062                            52      
00001062                            53      
00001062                            54      
00001062                            55      ;--- IBRDECOD: INICIO SALTO A DECOD
00001062                            56          ;*** En esta seccion debeis preparar la pila para llamar a la subrutina
00001062                            57          ;*** DECOD, llamar a la subrutina, y vaciar la pila correctamente,
00001062                            58          ;*** almacenando el resultado de la decodificacion en D1
00001062                            59  
00001062                            60              ; ESCRIBID VUESTRO CODIGO AQUI          
00001062                            61  IBREDECOD:
00001062  3F3C 0000                 62      MOVE.W #0,-(A7)         ; preparamos la pila
00001066  3F38 1032                 63      MOVE.W (EIR),-(A7)      ; metemos la instrucción en la pila
0000106A                            64      
0000106A  4EB9 000014AC             65      JSR DECOD               ; saltamos a la subrutina de librería
00001070                            66                                  ; de decodificación
00001070                            67                                  
00001070  544F                      68      ADDQ.W #2,A7            ; sumamos 2 a A7
00001072  321F                      69      MOVE.W (A7)+,D1         ; en D1 tenemos la instrucción a ejecutar
00001074                            70  
00001074                            71          
00001074                            72      ;--- FBRDECOD: FIN SALTO A DECOD
00001074                            73      
00001074                            74      
00001074                            75      
00001074                            76      ;--- IBREXEC: INICIO SALTO A FASE DE EJECUCION
00001074                            77          ;*** Esta seccion se usa para saltar a la fase de ejecucion
00001074                            78          ;*** NO HACE FALTA MODIFICARLA
00001074  C2FC 0006                 79      MULU #6,D1
00001078  2241                      80      MOVEA.L D1,A1
0000107A  4EE9 107E                 81      JMP JMPLIST(A1)
0000107E                            82  JMPLIST:
0000107E  4EF9 000010D8             83      JMP ELOA
00001084  4EF9 0000111C             84      JMP ESTO
0000108A  4EF9 00001150             85      JMP ELOIP
00001090  4EF9 00001190             86      JMP ESTIP
00001096  4EF9 000011C4             87      JMP EGOI
0000109C  4EF9 000011D6             88      JMP EGOZ
000010A2  4EF9 000011F4             89      JMP EGON
000010A8  4EF9 00001212             90      JMP EEXIT
000010AE  4EF9 00001218             91      JMP ECOPY
000010B4  4EF9 00001240             92      JMP EADD
000010BA  4EF9 0000127A             93      JMP ESUB
000010C0  4EF9 000012B8             94      JMP EAND
000010C6  4EF9 000012F2             95      JMP ESET
000010CC  4EF9 0000131A             96      JMP EADQ
000010D2  4EF9 00001342             97      JMP ELSH
000010D8                            98      ;--- FBREXEC: FIN SALTO A FASE DE EJECUCION
000010D8                            99      
000010D8                           100      
000010D8                           101      
000010D8                           102      ;--- IEXEC: INICIO EJECUCION
000010D8                           103          ;*** En esta seccion debeis implementar la ejecucion de cada einstr.
000010D8                           104      
000010D8                           105      ; ESCRIBID EN CADA ETIQUETA LA FASE DE EJECUCION DE CADA INSTRUCCION
000010D8                           106  ELOA:                       ; Ti <-- [M]
000010D8  3A38 1032                107      MOVE.W EIR, D5          ; metemos la instr. en D5
000010DC  4EB9 000013C8            108      JSR CogerM              ; sacamaos el valor de M
000010E2  CAFC 0002                109      MULU.W #2, D5
000010E6  D7C5                     110      ADDA.L D5, A3          ; guardamos el valor de M en D6
000010E8                           111      
000010E8  3C2B 1000                112      MOVE.W EMEM(A3),D6     ; sumamos la dirección de EMemoria + M y la 
000010EC                           113                              ; y la guardamos en A2
000010EC  3A38 1032                114      MOVE.W EIR, D5          ; movemos la inst. a D5, ya que hemos modificado D5
000010F0  4EB9 000013B4            115      JSR CogerI              ; sacamos el valor de I
000010F6  BA7C 0000                116      CMP #0, D5              ; comparamos I con 0              
000010FA  6600 000E                117      BNE I1_Load             ; si no son iguales significa que I es 1, por tanto,
000010FE                           118                              ; saltamos al caso donde I es 1
000010FE  31C6 1036                119      MOVE.W D6,ET0         ; cuando I es 0, guardamos el contenido de Emem + M
00001102                           120                              ; en ET0
00001102  40C2                     121      MOVE.W SR, D2           ; movemos los flags a D2
00001104  4EF9 00001110            122      JMP FINAL_Load          ; saltamos al final del ELoad    
0000110A                           123     
0000110A                           124     I1_Load:
0000110A  31C6 1038                125      MOVE.W D6,ET1
0000110E  40C2                     126      MOVE.W SR, D2           ; movemos los flags a D2
00001110                           127      
00001110                           128   FINAL_Load:
00001110  4244                     129      CLR.W D4                ; limpiamos el registro D4, para modificar los flags
00001112  4EB9 0000148A            130      JSR FLAGS_NZ
00001118  6000 FF32                131      BRA FETCH            
0000111C                           132  *--------------------------------------------------
0000111C                           133  ESTO:                       ; M <-- [Ti]
0000111C  3A38 1032                134      MOVE.W EIR, D5          ; metemos la instr. en D5
00001120  4EB9 000013C8            135      JSR CogerM              ; sacamaos el valor de M
00001126  3645                     136      MOVEA.W D5, A3           ; guardamos el valor de M en D6   
00001128                           137      
00001128  346B 1000                138      MOVEA.W EMEM(A3),A2     ; A2 <-- EMEM + M (direcciones de memoria)
0000112C                           139   
0000112C  3A38 1032                140      MOVE.W EIR, D5          ; metemos la instr. en D5
00001130  4EB9 000013B4            141      JSR CogerI
00001136  BA7C 0000                142      CMP #0, D5              ; si i = 1 saltamos al caso de ET1
0000113A  6600 000C                143      BNE I1_Store            
0000113E                           144      
0000113E  3478 1036                145      MOVE.W ET0, A2          ; movemos el contenido de ET0 a EMEM + M
00001142  4EF9 0000114C            146      JMP FINAL_Store
00001148                           147      
00001148                           148     I1_Store:
00001148  3478 1038                149      MOVE.W ET1, A2          ; movemos el contenido de ET1 a EMEM + M
0000114C                           150    
0000114C                           151    FINAL_Store:
0000114C  6000 FEFE                152      BRA FETCH
00001150                           153      
00001150                           154  *--------------------------------------------------
00001150                           155  ELOIP:                      ; Ti <-- [[Xb]], Xb <-- [Xb] + 1
00001150  3A38 1032                156      MOVE.W EIR, D5          ; metemos la instr. en D5
00001154  4EB9 0000139A            157      JSR CogerB              ; sacamaos el registro B
0000115A  344D                     158      MOVE.W A5, A2           ; guardamos el Rb en A2
0000115C                           159      
0000115C  3A38 1032                160      MOVE.W EIR, D5          ; metemos la inst. en D5
00001160  4EB9 000013B4            161      JSR CogerI              ; cogemos I
00001166  BA7C 0000                162      CMP #0, D5              ; comparamos D5(I) con 0
0000116A  6600 0010                163      BNE I1_LOIP             ; si no son iguales saltamos donde I = 1
0000116E                           164      
0000116E  31D2 1036                165      MOVE.W (A2),ET0         ; T0 <-- [[Rb]]
00001172  40C2                     166      MOVE.W SR, D2           ; guardamos los flags despues de la op.
00001174  5252                     167      ADD.W #1, (A2)          ; Xb <-- [Xb] + 1   
00001176  4EF9 00001184            168      JMP FINAL_LOIP
0000117C                           169      
0000117C                           170     I1_LOIP:
0000117C  31D2 1038                171      MOVE.W (A2),ET1         ; T1 <-- [[Rb]]
00001180  40C2                     172      MOVE.W SR, D2           ; guardamos los flags despues de la op.
00001182  5252                     173      ADD.W #1, (A2)          ; Xb <-- [Xb] + 1   
00001184                           174      
00001184                           175   FINAL_LOIP:
00001184  4244                     176      CLR.W D4                ; limpiamos D4 por si hay algo, ya que lo 
00001186  4EB9 0000148A            177      JSR FLAGS_NZ            ; necesitaremos D4 para actualizar los flags N y Z
0000118C                           178      
0000118C  6000 FEBE                179      BRA FETCH
00001190                           180  
00001190                           181  *--------------------------------------------------
00001190                           182  ESTIP:                      ; [Xb] <-- [Ti], Xb <-- [Xb] + 1
00001190  3A38 1032                183      MOVE.W EIR, D5          ; metemos la instr. en D5
00001194  4EB9 0000139A            184      JSR CogerB              ; sacamaos el registro B
0000119A  344D                     185      MOVE.W A5, A2           ; guardamos el Rb en A2
0000119C                           186      
0000119C  3A38 1032                187      MOVE.W EIR, D5          ; metemos la inst. en D5
000011A0  4EB9 000013B4            188      JSR CogerI              ; cogemos I
000011A6  BA7C 0000                189      CMP #0, D5              ; comparamos D5(I) con 0
000011AA  6600 000E                190      BNE I1_STIP             ; si no son iguales saltamos donde I = 1
000011AE                           191      
000011AE  34B8 1036                192      MOVE.W (ET0),(A2)       ; [Xb] <-- [T0]
000011B2  5252                     193      ADD.W #1, (A2)          ; Xb <-- [Xb] + 1  
000011B4  4EF9 000011C0            194      JMP FINAL_STIP
000011BA                           195      
000011BA                           196     I1_STIP:
000011BA  34B8 1036                197      MOVE.W (ET0),(A2)       ; [Xb] <-- [T0]
000011BE  5252                     198      ADD.W #1, (A2)          ; Xb <-- [Xb] + 1  
000011C0                           199      
000011C0                           200   FINAL_STIP:
000011C0  4EF8 104C                201      JMP FETCH
000011C4                           202  
000011C4                           203  *--------------------------------------------------
000011C4                           204  EGOI:                       ; PC <-- M
000011C4                           205  
000011C4  3A38 1032                206      MOVE.W EIR, D5          ; movemos la instr. a D5
000011C8  4EB9 000013C8            207      JSR CogerM              ; llamamos a la subr. para coger M
000011CE  31C5 1034                208      MOVE.W D5, EPC          ; guardamos D5 en el PC del eprograma
000011D2                           209      
000011D2  6000 FE78                210      BRA FETCH
000011D6                           211                     
000011D6                           212  *--------------------------------------------------
000011D6                           213  EGOZ:                       ; si Z=1,  PC <-- M
000011D6                           214  
000011D6  3438 1046                215      MOVE.W ESR, D2          ; movemos los eflags a D2
000011DA  0802 0000                216      BTST.L #0, D2           ; comprobamos si el eflag Z es 1
000011DE  6700 0010                217      BEQ Z0                  ; si es 0 saltamos al final de la instr.
000011E2                           218      
000011E2  3A38 1032                219      MOVE.W EIR, D5          ; movemos la instr. a D5
000011E6  4EB9 000013C8            220      JSR CogerM              ; llamamos a la subr. para coger M
000011EC  31C5 1034                221      MOVE.W D5, EPC          ; guardamos D5 en el PC del eprograma
000011F0                           222  
000011F0                           223    Z0:
000011F0  6000 FE5A                224      BRA FETCH    
000011F4                           225      
000011F4                           226  *--------------------------------------------------
000011F4                           227  EGON:                       ; si N=1,  PC <-- M
000011F4                           228  
000011F4  3438 1046                229      MOVE.W ESR, D2          ; movemos los eflags a D2
000011F8  0802 0001                230      BTST.L #1, D2           ; comprobamos si el eflag N es 1
000011FC  6700 0010                231      BEQ N0                  ; si es 0 saltamos al final de la instr.
00001200                           232      
00001200  3A38 1032                233      MOVE.W EIR, D5          ; movemos la instr. a D5
00001204  4EB9 000013C8            234      JSR CogerM              ; llamamos a la subr. para coger M
0000120A  31C5 1034                235      MOVE.W D5, EPC          ; guardamos D5 en el PC del eprograma
0000120E                           236  
0000120E                           237    N0:
0000120E  6000 FE3C                238      BRA FETCH    
00001212                           239      
00001212                           240  *--------------------------------------------------
00001212                           241  EEXIT:                      ; Detiene la maquina
00001212  4EF9 0000157A            242      JMP SIMHALT
00001218                           243  *--------------------------------------------------
00001218                           244  ECOPY:                      ; Rc <-- Rb
00001218                           245  
00001218  3A38 1032                246      MOVE.W EIR, D5          ; movemos la inst. a D5
0000121C  4EB9 0000139A            247      JSR CogerB              ; cogemos B
00001222  344D                     248      MOVE.W A5, A2           ; guardamos B en A2
00001224                           249      
00001224  3A38 1032                250      MOVE.W EIR, D5          ; movemos de nuevo la inst. a D5,ya que se modificó
00001228  4EB9 000013A8            251      JSR CogerC              ; cogemos C
0000122E  324D                     252      MOVE.W A5, A1           ; guardamos C en A1
00001230                           253      
00001230  3292                     254      MOVE.W (A2),(A1)        ; copiamos el contenido de A2 dentro de A1
00001232                           255      
00001232  40C2                     256      MOVE.W SR, D2           ; copiamos los flags a D2
00001234  4244                     257      CLR.W D4                ; limpiamos D4 por si hay algo, ya que lo 
00001236  4EB9 0000148A            258      JSR FLAGS_NZ            ; necesitaremos D4 para actualizar los flags N y Z
0000123C                           259      
0000123C  6000 FE0E                260      BRA FETCH
00001240                           261      
00001240                           262  *--------------------------------------------------
00001240                           263  EADD:                       ; Rc <-- [Rb] + [Ra]
00001240                           264  
00001240  3A38 1032                265      MOVE.W EIR, D5          ; movemos la instr. a D5
00001244  4EB9 0000138C            266      JSR CogerA              ; llamamos a la sub. de usuario para coger el valor
0000124A  324D                     267      MOVE.W A5, A1           ; de A y lo movemos a A1
0000124C                           268      
0000124C  3A38 1032                269      MOVE.W EIR, D5
00001250  4EB9 0000139A            270      JSR CogerB              ; llamamos a la sub. de usuario para coger el valor
00001256  344D                     271      MOVE.W A5, A2           ; de B y lo movemos a A2
00001258                           272      
00001258  3A38 1032                273      MOVE.W EIR, D5
0000125C  4EB9 000013A8            274      JSR CogerC              ; llamamos a la sub. de usuario para coger el valor
00001262  364D                     275      MOVE.W A5, A3           ; de C y lo movemos a A3
00001264                           276      
00001264  4286                     277      CLR.L D6                ; preparamos D6 para poder poner el resultado
00001266  DC51                     278      ADD.W (A1),D6           ; sumamos el contenido de A1 (A) a D6
00001268  DC52                     279      ADD.W (A2),D6           ; sumamos el contenido de A2 (B) a D6
0000126A                           280      
0000126A  40C2                     281      MOVE.W SR,D2            ; guardamos los flags del 68k en D2
0000126C  4244                     282      CLR.W D4                
0000126E  4EB9 0000147C            283      JSR Flags_CNZ           ; actualizamos los eflags
00001274                           284      
00001274  3686                     285      MOVE.W D6, (A3)         ; movemos el resultado a Rc
00001276                           286      
00001276  6000 FDD4                287      BRA FETCH
0000127A                           288  *--------------------------------------------------    
0000127A                           289  ESUB:                       ; Rc <-- [Rb] - [Ra]
0000127A                           290  
0000127A  3A38 1032                291      MOVE.W EIR, D5          ; movemos la instr. a D5
0000127E  4EB9 0000138C            292      JSR CogerA              ; llamamos a la sub. de usuario para coger el valor
00001284  324D                     293      MOVE.W A5, A1           ; de A y lo movemos a A1
00001286                           294      
00001286  3A38 1032                295      MOVE.W EIR, D5
0000128A  4EB9 0000139A            296      JSR CogerB              ; llamamos a la sub. de usuario para coger el valor
00001290  344D                     297      MOVE.W A5, A2           ; de B y lo movemos a A2
00001292                           298      
00001292  3A38 1032                299      MOVE.W EIR, D5
00001296  4EB9 000013A8            300      JSR CogerC              ; llamamos a la sub. de usuario para coger el valor
0000129C  364D                     301      MOVE.W A5, A3           ; de C y lo movemos a A3
0000129E                           302      
0000129E  4286                     303      CLR.L D6                ; preparamos D6 para poder poner el resultado
000012A0  DC51                     304      ADD.W (A1),D6           ; sumamos el contenido de A1 (A) a D6
000012A2  4646                     305      NOT.W D6                ; negamos y sumamos 1 a A para hacer una resta
000012A4  5246                     306      ADDQ.W #1, D6
000012A6  DC52                     307      ADD.W (A2),D6           ; B + (-A)
000012A8                           308  
000012A8  40C2                     309      MOVE.W SR,D2            ; guardamos los flags del 68k en D2
000012AA  4244                     310      CLR.W D4                ; limpiamos D4
000012AC  4EB9 0000147C            311      JSR Flags_CNZ           ; actualizamos los eflags
000012B2                           312      
000012B2  3686                     313      MOVE.W D6, (A3)         ; movemos el resultado a Rc
000012B4                           314      
000012B4  6000 FD96                315      BRA FETCH
000012B8                           316  *--------------------------------------------------    
000012B8                           317  EAND:                       ; Rc <-- [Rb] and [Ra]
000012B8                           318  
000012B8  3A38 1032                319      MOVE.W EIR, D5          ; movemos la instr. a D5
000012BC  4EB9 0000138C            320      JSR CogerA              ; llamamos a la sub. de usuario para coger el valor
000012C2  324D                     321      MOVE.W A5, A1           ; de A y lo movemos a A1
000012C4                           322      
000012C4  3A38 1032                323      MOVE.W EIR, D5
000012C8  4EB9 0000139A            324      JSR CogerB              ; llamamos a la sub. de usuario para coger el valor
000012CE  344D                     325      MOVE.W A5, A2           ; de B y lo movemos a A2
000012D0                           326      
000012D0  3A38 1032                327      MOVE.W EIR, D5
000012D4  4EB9 000013A8            328      JSR CogerC              ; llamamos a la sub. de usuario para coger el valor
000012DA  364D                     329      MOVE.W A5, A3           ; de C y lo movemos a A3
000012DC                           330  
000012DC  3C11                     331      MOVE.W (A1),D6          ; movemos A y B a los registros de dat.
000012DE  3E12                     332      MOVE.W (A2),D7
000012E0  CC47                     333      AND.W   D7 ,D6          ; A and B
000012E2                           334      
000012E2  40C2                     335      MOVE.W SR,D2            ; guardamos los flags del 68k en D2
000012E4  4244                     336      CLR.W D4                ; limpiamos D4 
000012E6  4EB9 0000148A            337      JSR Flags_NZ            ; actualizamos los eflags
000012EC                           338      
000012EC  3686                     339      MOVE.W D6, (A3)         ; movemos el resultado a Rc
000012EE                           340      
000012EE  6000 FD5C                341      BRA FETCH
000012F2                           342  *--------------------------------------------------
000012F2                           343  ESET:                       ; Rc <-- k (ext. signo)
000012F2  3A38 1032                344      MOVE.W EIR, D5          ; movemos la instr. a D5
000012F6  4EB9 000013A8            345      JSR CogerC              ; llamamos a la sub. de usuario para coger el valor
000012FC  364D                     346      MOVE.W A5, A3           ; de C y lo movemos a A3
000012FE                           347      
000012FE  3A38 1032                348      MOVE.W EIR, D5          ; movemos la instr. a D5
00001302  4EB9 000013D0            349      JSR CogerK              ; cogemos k (dentro se realiza la ext. de signo)
00001308  3C05                     350      MOVE.W D5, D6           ; guardamos k en D6
0000130A                           351      
0000130A  3686                     352      MOVE.W D6,(A3)          ; guardamos D6 (k) dentro de A3 (C)
0000130C                           353      
0000130C  40C2                     354      MOVE.W SR,D2            ; guardamos los flags del 68k en D2
0000130E  4244                     355      CLR.W D4                ; limpiamos D4 por si hay algo, ya que lo 
00001310  4EB9 0000148A            356      JSR FLAGS_NZ            ; necesitaremos D4 para actualizar los flags N y Z
00001316                           357  
00001316  6000 FD34                358      BRA FETCH
0000131A                           359  
0000131A                           360  *--------------------------------------------------
0000131A                           361  EADQ:                       ; Rc <-- [Rc] + k (ext. signo)
0000131A  3A38 1032                362      MOVE.W EIR, D5          ; movemos la instr. a D5
0000131E  4EB9 000013A8            363      JSR CogerC              ; llamamos a la sub. de usuario para coger el valor
00001324  364D                     364      MOVE.W A5, A3           ; de C y lo movemos a A3
00001326                           365      
00001326  3A38 1032                366      MOVE.W EIR, D5          ; movemos la instr. a D5
0000132A  4EB9 000013D0            367      JSR CogerK              ; cogemos k (dentro se realiza la ext. de signo)
00001330  3C05                     368      MOVE.W D5, D6           ; guardamos k en D6
00001332                           369      
00001332  DD53                     370      ADD.W D6,(A3)           ; sumamos D6 (k) con A3(C) y lo guardamos en A3(C)
00001334                           371      
00001334  40C2                     372      MOVE.W SR,D2            ; guardamos los flags del 68k en D2
00001336  4244                     373      CLR.W D4                ; limpiamos D4 por si hay algo, ya que lo 
00001338  4EB9 0000147C            374      JSR FLAGS_CNZ           ; necesitaremos D4 para actualizar todos los eflags
0000133E                           375  
0000133E  6000 FD0C                376      BRA FETCH
00001342                           377  *--------------------------------------------------
00001342                           378  ELSH:                       ; si n=0 => Rb <-- [Rb] left shift p
00001342                           379                              ; si n=1 => Rb <-- [Rb] right shift p
00001342  3A38 1032                380      MOVE.W EIR, D5          ; movemos la inst. a D5
00001346  4EB9 0000139A            381      JSR CogerB              ; cogemos el registro B
0000134C  344D                     382      MOVE.W A5, A2           ; guardamos el Rb en A2
0000134E  3E12                     383      MOVE.W (A2),D7          ; movemos el contenido de A2(B) a un registro
00001350                           384                              ; temporal
00001350                           385      
00001350  3A38 1032                386      MOVE.W EIR, D5          ; movemos la inst. a D5
00001354  4EB9 000013C0            387      JSR CogerP              ; cogemos P
0000135A  3C05                     388      MOVE.W D5, D6           ; guardamos D5(P) en D6
0000135C                           389  
0000135C  3A38 1032                390      MOVE.W EIR, D5          ; movemos la intsrucción a D5
00001360  4EB9 000013BA            391      JSR CogerN              ; cogemos el valor de N
00001366  BA7C 0000                392      CMP #0, D5              ; comparamos 0 con N
0000136A  6600 000E                393      BNE RShift              ; si N es 1 saltamos a right shift
0000136E                           394      
0000136E  ED6F                     395      LSL.W D6 , D7           ; n=0, por tanto hacemos un LSL con desp. D6(P)
00001370  40C2                     396      MOVE.W SR, D2           ; guardamos los flags después de la operación
00001372  3447                     397      MOVE.W D7, A2           ; guardamos el resultado en A2(B)
00001374  4EF9 00001380            398      JMP FINAL_LSH           ; saltamos al final
0000137A                           399      
0000137A                           400     RShift:
0000137A  EC6F                     401      LSR.W D6, D7            ; n=1, por tanto hacemos un LSR con desp. D6(P)
0000137C  40C2                     402      MOVE.W SR, D2           ; guardamos los flags 
0000137E  3447                     403      MOVE.W D7, A2           ; guardamos el resultado en A2(B)
00001380                           404      
00001380                           405   FINAL_LSH:
00001380  4244                     406      CLR.W D4                ; limpiamos D4 porque lo utilizamos para actualizar
00001382  4EB9 0000147C            407      JSR FLAGS_CNZ           ; los flags CNZ
00001388                           408      
00001388  6000 FCC2                409      BRA FETCH
0000138C                           410      
0000138C                           411  *--------------------------------------------------
0000138C                           412      ;--- FEXEC: FIN EJECUCION
0000138C                           413      
0000138C                           414      
0000138C                           415  
0000138C                           416      ;--- ISUBR: INICIO SUBRUTINAS
0000138C                           417          ;*** Aqui debeis incluir las subrutinas que necesite vuestra solucion
0000138C                           418          ;*** SALVO DECOD, que va en la siguiente seccion
0000138C                           419  
0000138C                           420              ; ESCRIBID VUESTRO CODIGO AQUI
0000138C                           421              
0000138C                           422  CogerA:
0000138C  E08D                     423      LSR.L #8,D5             ; movemos D5 8 posiciones a la derecha
0000138E  CA7C 0007                424      AND.W #$0007,D5         ; con una máscara, cogemos el valor de A (aaa)
00001392                           425      
00001392  4EB9 000013DA            426      JSR REGISTROS           ; miramos a qué registro se corresponde
00001398                           427      
00001398  4E75                     428      RTS
0000139A                           429      
0000139A                           430      
0000139A                           431  CogerB:
0000139A  E88D                     432      LSR.L #4,D5             ; movemos D5 4 posiciones a la derecha
0000139C  CA7C 0007                433      AND.W #$0007,D5         ; con una máscara, cogemos el valor de B (bbb)
000013A0                           434      
000013A0  4EB9 000013DA            435      JSR REGISTROS           ; miramos a qué registro se corresponde
000013A6                           436      
000013A6  4E75                     437      RTS
000013A8                           438  
000013A8                           439  
000013A8                           440  CogerC:
000013A8  CA7C 0007                441      AND.W #$0007,D5         ; con una máscara, cogemos el valor de C (ccc)
000013AC                           442  
000013AC  4EB9 000013DA            443      JSR REGISTROS           ; miramos a qué registro se corresponde
000013B2                           444      
000013B2  4E75                     445      RTS
000013B4                           446     
000013B4                           447  CogerI:
000013B4  CA7C 0001                448      AND.W #0001,D5          ; con una máscara, cogemos el valor de I
000013B8                           449      
000013B8  4E75                     450      RTS
000013BA                           451      
000013BA                           452  CogerN:
000013BA  CA7C 0001                453      AND.W #0001,D5          ; con una máscara, cogemos el valor de N
000013BE                           454      
000013BE  4E75                     455      RTS
000013C0                           456      
000013C0                           457  CogerP:
000013C0  E08D                     458      LSR.L #8,D5             ; movemos D5 8 posiciones a la derecha
000013C2  CA7C 0007                459      AND.W #0007,D5          ; con una máscara, cogemos el valor de P (ppp)
000013C6                           460      
000013C6  4E75                     461      RTS
000013C8                           462      
000013C8                           463  CogerM:
000013C8  E28D                     464      LSR.L #1,D5             ; movemos D5 4 posiciones a la derecha
000013CA  CA7C 00FF                465      AND.W #$00FF,D5         ; con una máscara, cogemos el valor de M (mmmmmmmm)
000013CE                           466      
000013CE  4E75                     467      RTS
000013D0                           468     
000013D0                           469  CogerK:
000013D0  E68D                     470      LSR.L #3,D5             ; movemos D5 3 posiciones a la derecha
000013D2  CA3C 00FF                471      AND.B #$00FF,D5         ; con una máscara, cogemos el valor de K (kkkkkkkk)
000013D6  4885                     472      EXT.W D5                ; hacemos una extensión de signo (byte -> word)
000013D8                           473      
000013D8  4E75                     474      RTS
000013DA                           475  
000013DA                           476  *--------------------------------------
000013DA                           477  
000013DA                           478  REGISTROS:
000013DA  0805 0002                479      BTST.L #2,D5            ; miramos el tercer bit del registro
000013DE  6600 0026                480      BNE REGISTROS_1XX       ; si no es 0, saltamos para mirar el registro 1XX
000013E2                           481      
000013E2                           482     ;0XX
000013E2  0805 0001                483      BTST.L #1,D5            ; miramos el segundo bit del registro
000013E6  6600 0010                484      BNE REGISTROS_01X       ; si no es 0, saltamos para mirar el registro 01X
000013EA                           485      
000013EA                           486          ;00X
000013EA  0805 0000                487           BTST.L #0,D5       ; miramos el primer bit del registro
000013EE  6700 003A                488           BEQ REGISTRO_T0    ; si es 0, el registro es B0
000013F2  4EF9 00001434            489           JMP REGISTRO_T1    ; si es 0, el registro es B1
000013F8                           490      
000013F8                           491          REGISTROS_01X:
000013F8  0805 0000                492           BTST.L #0,D5       ; miramos el primer bit del registro
000013FC  6700 0040                493           BEQ REGISTRO_X2    ; si es 0, el registro es R2
00001400  4EF9 00001448            494           JMP REGISTRO_X3    ; si es 0, el registro es R3
00001406                           495      
00001406                           496     REGISTROS_1XX:
00001406  0805 0001                497      BTST.L #1,D5            ; miramos el segundo bit del registro
0000140A  6600 0010                498      BNE REGISTROS_11X       ; si no es 0, saltamos para mirar el registro 11X
0000140E                           499      
0000140E                           500          ;10X
0000140E  0805 0000                501           BTST.L #0,D5       ; miramos el primer bit del registro
00001412  6700 003E                502           BEQ REGISTRO_X4    ; si es 0, el registro es R4
00001416  4EF9 0000145C            503           JMP REGISTRO_X5    ; si es 0, el registro es R5
0000141C                           504      
0000141C                           505          REGISTROS_11X:
0000141C  0805 0000                506           BTST.L #0,D5       ; miramos el primer bit del registro
00001420  6700 0044                507           BEQ REGISTRO_X6    ; si es 0, el registro es T6
00001424  4EF9 00001470            508           JMP REGISTRO_X7    ; si es 0, el registro es T7
0000142A                           509      
0000142A                           510  
0000142A                           511    ; A partir de aquí guardamos las direcciones y salimos de la subrutina 
0000142A                           512     REGISTRO_T0:
0000142A  4BF8 1036                513      LEA.L ET0,A5            ; guardamos el contenido de ET0 en A5
0000142E  4EF9 0000147A            514      JMP FIN_REGISTROS       ; saltamos al final de la subrutina de registros
00001434                           515      
00001434                           516     REGISTRO_T1:
00001434  4BF8 1038                517      LEA.L ET1,A5            ; guardamos el contenido de ET1 en A5
00001438  4EF9 0000147A            518      JMP FIN_REGISTROS       ; saltamos al final de la subrutina de registros
0000143E                           519      
0000143E                           520     REGISTRO_X2:
0000143E  4BF8 103A                521      LEA.L EX2,A5            ; guardamos el contenido de EX2 en A5
00001442  4EF9 0000147A            522      JMP FIN_REGISTROS       ; saltamos al final de la subrutina de registros
00001448                           523      
00001448                           524     REGISTRO_X3:
00001448  4BF8 103C                525      LEA.L EX3,A5            ; guardamos el contenido de EX3 en A5
0000144C  4EF9 0000147A            526      JMP FIN_REGISTROS       ; saltamos al final de la subrutina de registros
00001452                           527      
00001452                           528     REGISTRO_X4:
00001452  4BF8 103E                529      LEA.L EX4,A5            ; guardamos el contenido de EX4 en A5
00001456  4EF9 0000147A            530      JMP FIN_REGISTROS       ; saltamos al final de la subrutina de registros
0000145C                           531      
0000145C                           532     REGISTRO_X5:
0000145C  4BF8 1040                533      LEA.L EX5,A5            ; guardamos el contenido de EX5 en A5
00001460  4EF9 0000147A            534      JMP FIN_REGISTROS       ; saltamos al final de la subrutina de registros
00001466                           535      
00001466                           536     REGISTRO_X6:
00001466  4BF8 1042                537      LEA.L EX6,A5            ; guardamos el contenido de EX6 en A5
0000146A  4EF9 0000147A            538      JMP FIN_REGISTROS       ; saltamos al final de la subrutina de registros
00001470                           539      
00001470                           540     REGISTRO_X7:
00001470  4BF8 1044                541      LEA.L EX7,A5            ; guardamos el contenido de EX7 en A5
00001474  4EF9 0000147A            542      JMP FIN_REGISTROS       ; saltamos al final de la subrutina de registros
0000147A                           543      
0000147A                           544     FIN_REGISTROS: 
0000147A  4E75                     545      RTS
0000147C                           546  *--------------------------------------
0000147C                           547  ; Flags 68k = NZVC, FLAGS HAL9000 = 0CNZ  
0000147C                           548  
0000147C                           549  FLAGS_CNZ:
0000147C  3602                     550      MOVE D2,D3              ; copiamos los flags para poder manipularlos
0000147E  0803 0000                551      BTST.L #0,D3            ; miramos C
00001482  6700 0006                552      BEQ FLAGS_NZ            ; si C es 0, saltamos a mirar el flag Z
00001486                           553      
00001486  08C4 0002                554      BSET.L #2,D4              ; si no es 0, pondremos a 1 el valor de C en D4
0000148A                           555      
0000148A                           556  *--------------------------------------    
0000148A                           557  FLAGS_NZ:
0000148A  3602                     558      MOVE.W D2,D3            ; copiamos los flags para poder manipularlos
0000148C  0803 0003                559      BTST.L #3,D3            ; miramos N
00001490  6700 0006                560      BEQ FLAG_Z              ; si N es 0, saltamos a mirar el siguiente flag
00001494                           561      
00001494  08C4 0001                562      BSET.L #1,D4            ; si no es 0, pondremos a 1 el valor de N en D4
00001498                           563      
00001498                           564     FLAG_Z:
00001498  3602                     565      MOVE.W D2,D3            ; copiamos los flags para poder manipularlos
0000149A  0803 0002                566      BTST.L #2,D3            ; miramos Z
0000149E  6700 0006                567      BEQ FINAL_FLAGS         ; si Z es 0, saltamos al final de los flags
000014A2                           568      
000014A2  08C4 0000                569      BSET.L #0,D4            ; si no es 0, pondremos a 1 el valor de Z en D4
000014A6                           570      
000014A6                           571     FINAL_FLAGS:
000014A6  31C4 1046                572      MOVE.W D4,ESR           ; movemos D4 (flags finales) a ESR, los eflags
000014AA  4E75                     573      RTS
000014AC                           574          
000014AC                           575          
000014AC                           576      ;--- FSUBR: FIN SUBRUTINAS
000014AC                           577      
000014AC                           578      
000014AC                           579  
000014AC                           580      ;--- IDECOD: INICIO DECOD
000014AC                           581          ;*** Tras la etiqueta DECOD, debeis implementar la subrutina de 
000014AC                           582          ;*** decodificacion, que debera ser de libreria, siguiendo la interfaz
000014AC                           583          ;*** especificada en el enunciado
000014AC                           584  DECOD:
000014AC                           585              ; ESCRIBID VUESTRO CODIGO AQUI
000014AC                           586              
000014AC  3F00                     587      MOVE.W D0,-(A7)         ; guardamos D0 en la pila
000014AE  3F01                     588      MOVE.W D1,-(A7)         ; guardamos D1 en la pila
000014B0  302F 0008                589      MOVE.W 8(A7),D0         ; la instrucción que hemos guardado la pasamos a D0
000014B4                           590  
000014B4  323C 0000                591      MOVE.W #0, D1           ; D1 contiene el id de la instrucción
000014B8  0800 000F                592      BTST.L #15, D0          ; miramos el bit 16º de la instr.
000014BC  6600 0050                593      BNE DECOD_1XXX          ; si no es 0, saltamos a para la instr. 1XXX
000014C0                           594      
000014C0                           595      ;0XXX
000014C0  0800 000E                596      BTST.L #14, D0          ; miramos el bit 15º de la instr.
000014C4  6600 0028                597      BNE DECOD_01XX          ; si no es 0, saltamos a para la instr. 01XX
000014C8                           598  
000014C8                           599          ;00XX
000014C8  0800 000D                600          BTST.L #13, D0      ; miramos el bit 14º de la instr.
000014CC  6600 0010                601          BNE DECOD_001X      ; si no es 0, saltamos a para la instr. 001X
000014D0                           602          
000014D0                           603              ;000X
000014D0  0800 000C                604              BTST.L #12, D0  ; miramos el bit 13º de la instr.
000014D4  6600 0098                605              BNE FINAL_AUX   ; si no es 0, saltamos a final aux para sumar 1
000014D8  4EF9 00001570            606              JMP FINAL       ; si es 0, saltamos al final
000014DE                           607              
000014DE                           608            DECOD_001X:
000014DE  5441                     609              ADDQ.W #2, D1   ; sumamos 2 al id de la instr.
000014E0  0800 000C                610              BTST.L #12, D0  ; miramos el bit 13º de la instr.  
000014E4  6600 0088                611              BNE FINAL_AUX   ; si no es 0, saltamos a final aux para sumar 1
000014E8  4EF9 00001570            612              JMP FINAL       ; si es 0, saltamos al final
000014EE                           613           
000014EE                           614        DECOD_01XX:
000014EE  5841                     615          ADDQ.W #4, D1       ; sumamos 4 al id de la instr.
000014F0  0800 000D                616          BTST.L #13, D0      ; miramos el bit 14º de la instr.
000014F4  6600 0010                617          BNE DECOD_0110      ; si no es 0, saltamos a la única otra 
000014F8                           618                              ; posibilidad que es 0110
000014F8                           619             ;010X
000014F8  0800 000C                620             BTST.L #12, D0   ; miramos el bit 13º de la instr.
000014FC  6600 0070                621             BNE FINAL_AUX    ; si no es 0, saltamos a final aux para sumar 1
00001500  4EF9 00001570            622             JMP FINAL        ; si es 0, saltamos directamente al final
00001506                           623        
00001506                           624        DECOD_0110:
00001506  5C41                     625          ADDQ.W #6, D1       ; sumamos 6 directamente porque solo hay 1 instr.
00001508  4EF9 00001570            626          JMP FINAL           ; que empiece por 011
0000150E                           627          
0000150E                           628    DECOD_1XXX:
0000150E  5E41                     629      ADDQ.W #7, D1           ; id = 7
00001510  0800 000E                630      BTST.L #14, D0          ; miramos el bit 15º de la instr.
00001514  6600 0008                631      BNE DECOD_11XXX         ; si no es 0, saltamos a la instr. 10XXX
00001518  4EF9 00001570            632      JMP FINAL               ; como la única instr. con 10 sumamos el id
0000151E                           633                              ; y saltamos directamente al final
0000151E                           634          
0000151E                           635        
0000151E                           636    DECOD_11XXX:
0000151E  0800 000D                637      BTST.L #13, D0          ; miramos el bit 14º 
00001522  6600 002A                638      BNE DECOD_111XX         ; si no es 0, saltamos a 111XX
00001526                           639      
00001526                           640          ;110XX
00001526  0800 000C                641          BTST.L #12, D0      ; miramos el bit 13º
0000152A  6600 0012                642          BNE DECOD_1101X
0000152E                           643          
0000152E                           644              ;1100X
0000152E  5241                     645              ADDQ.W #1, D1   ; id = 8
00001530  0800 000B                646              BTST.L #11, D0  ; miramos el bit 12º 
00001534  6600 0038                647              BNE FINAL_AUX   ; si es 1, saltamos al final aux para sumar 1
00001538  4EF9 00001570            648              JMP FINAL       ; si es 0, saltamos directamente al final
0000153E                           649  
0000153E                           650  
0000153E                           651             DECOD_1101X:
0000153E  5641                     652              ADDQ.W #3, D1   ; id = 10
00001540  0800 000B                653              BTST.L #11, D0  ; miramos el bit 12º
00001544  6600 0028                654              BNE FINAL_AUX   ; si es 1, saltamos al final aux para sumar 1
00001548  4EF9 00001570            655              JMP FINAL       ; si es 0, saltamos directamente al final
0000154E                           656        
0000154E                           657        DECOD_111XX:
0000154E  5A41                     658          ADDQ.W #5, D1       ; id = 12
00001550  0800 000C                659          BTST.L #12, D0      ; miramos el bit 13º
00001554  6600 0010                660          BNE DECOD_11110     ; si es 1, saltamos a 11110
00001558                           661          
00001558                           662              ;11100
00001558  0800 000B                663              BTST.L #11, D0  ; miramos el bit 12º
0000155C  6600 0010                664              BNE FINAL_AUX   ; si es 1, sumamos 1 al id
00001560  4EF9 00001570            665              JMP FINAL       ; si es 0, saltamos al final
00001566                           666              
00001566                           667            DECOD_11110:
00001566  5441                     668              ADDQ.W #2, D1   ; id = 14
00001568  4EF9 00001570            669              JMP FINAL
0000156E                           670  
0000156E                           671     FINAL_AUX:
0000156E  5241                     672      ADDQ.W #1,D1            ; sumamos 1 al id
00001570                           673      
00001570                           674     FINAL: 
00001570  3F41 000A                675      MOVE.W D1,10(A7)        ; guardamos el id en la pila
00001574  321F                     676      MOVE.W (A7)+,D1         ; sacamos D1 de la pila
00001576  301F                     677      MOVE.W (A7)+,D0         ; sacamos D0 de la pila
00001578                           678      
00001578  4E75                     679      RTS
0000157A                           680  
0000157A                           681  
0000157A                           682      ;--- FDECOD: FIN DECOD
0000157A                           683      
0000157A                           684  SIMHALT:
0000157A  FFFF FFFF                685      SIMHALT                 ; detiene la máquina
0000157E                           686      END    START

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
COGERA              138C
COGERB              139A
COGERC              13A8
COGERI              13B4
COGERK              13D0
COGERM              13C8
COGERN              13BA
COGERP              13C0
DECOD               14AC
DECOD_001X          14DE
DECOD_0110          1506
DECOD_01XX          14EE
DECOD_1101X         153E
DECOD_11110         1566
DECOD_111XX         154E
DECOD_11XXX         151E
DECOD_1XXX          150E
EADD                1240
EADQ                131A
EAND                12B8
ECOPY               1218
EEXIT               1212
EGOI                11C4
EGON                11F4
EGOZ                11D6
EIR                 1032
ELOA                10D8
ELOIP               1150
ELSH                1342
EMEM                1000
EPC                 1034
ESET                12F2
ESR                 1046
ESTIP               1190
ESTO                111C
ESUB                127A
ET0                 1036
ET1                 1038
EX2                 103A
EX3                 103C
EX4                 103E
EX5                 1040
EX6                 1042
EX7                 1044
FETCH               104C
FINAL               1570
FINAL_AUX           156E
FINAL_FLAGS         14A6
FINAL_LOAD          1110
FINAL_LOIP          1184
FINAL_LSH           1380
FINAL_STIP          11C0
FINAL_STORE         114C
FIN_REGISTROS       147A
FLAGS_CNZ           147C
FLAGS_NZ            148A
FLAG_Z              1498
I1_LOAD             110A
I1_LOIP             117C
I1_STIP             11BA
I1_STORE            1148
IBREDECOD           1062
JMPLIST             107E
N0                  120E
REGISTROS           13DA
REGISTROS_01X       13F8
REGISTROS_11X       141C
REGISTROS_1XX       1406
REGISTRO_T0         142A
REGISTRO_T1         1434
REGISTRO_X2         143E
REGISTRO_X3         1448
REGISTRO_X4         1452
REGISTRO_X5         145C
REGISTRO_X6         1466
REGISTRO_X7         1470
RSHIFT              137A
SIMHALT             157A
START               1048
Z0                  11F0
