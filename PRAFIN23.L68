00001026 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 18/05/2023 12:33:19

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : PRAFIN23
00000000                             3  * Written by : <nombres completos de los autores>
00000000                             4  * Date       : 19/05/2023
00000000                             5  * Description: Emulador de la HAL9000
00000000                             6  
00000000                             7  * Dudas = 
00000000                             8  * -(instrucciones ADD) cuando coges un reg y lo sumas
00000000                             9  *   hay que hacer (A1) o A1
00000000                            10  * - instrucciones LOIP y STIP  ¿Xb <-- [Xb] + 1? ¿es pila?
00000000                            11  * - Diferencia entre SET y ADQ solo move en vez de add? 
00000000                            12  *-----------------------------------------------------------
00001000                            13      ORG $1000
00001000= 000F C012 400A D...       14  EMEM: DC.W $000F,$C012,$400A,$D222,$8000,$CA22,$8000,$0001
00001010= 0000                      15  EIR: DC.W 0 ;eregistro de instruccion
00001012= 0000                      16  EPC: DC.W 0 ;econtador de programa
00001014= 0000                      17  ET0: DC.W 0 ;eregistro T0
00001016= 0000                      18  ET1: DC.W 0 ;eregistro T1
00001018= 0000                      19  EX2: DC.W 0 ;eregistro X2
0000101A= 0000                      20  EX3: DC.W 0 ;eregistro X3
0000101C= 0000                      21  EX4: DC.W 0 ;eregistro X4
0000101E= 0000                      22  EX5: DC.W 0 ;eregistro X5
00001020= 0000                      23  EX6: DC.W 0 ;eregistro X6
00001022= 0000                      24  EX7: DC.W 0 ;eregistro X7
00001024= 0000                      25  ESR: DC.W 0 ;eregistro de estado (00000000 00000CNZ
00001026                            26  
00001026                            27  START:
00001026  4278 1012                 28      CLR.W EPC
0000102A                            29  
0000102A                            30  FETCH:
0000102A                            31      ;--- IFETCH: INICIO FETCH
0000102A                            32          ;*** En esta seccion debeis introducir el codigo necesario para cargar
0000102A                            33          ;*** en el EIR la siguiente instruccion a ejecutar, indicada por el EPC,
0000102A                            34          ;*** y dejar listo el EPC para que apunte a la siguiente instruccion
0000102A                            35      
0000102A                            36              ; ESCRIBID VUESTRO CODIGO AQUI      
0000102A                            37          
0000102A  3038 1012                 38      MOVE.W EPC,D0           ; movemos el contador a D0
0000102E  C0FC 0002                 39      MULU.W #2,D0            ; multiplicamos x2 D0
00001032                            40      
00001032  41F8 1000                 41      LEA.L EMEM,A0           ; cogemos la dirección de la memoria
00001036  D0C0                      42      ADD.W D0,A0             ; sumamos D0 (PC) a A0 para tener la dirección de
00001038                            43                                  ; la instrucción a ejecutar
00001038                            44      
00001038  5278 1012                 45      ADD.W #1,EPC            ; sumamos 1 al EPC para ya apuntar a la siguiente
0000103C  31D0 1010                 46      MOVE.W (A0),EIR         ; movemos la instrucción al eregistro
00001040                            47                                  ; de instrucción
00001040                            48      
00001040                            49          
00001040                            50      ;--- FFETCH: FIN FETCH
00001040                            51      
00001040                            52      
00001040                            53      
00001040                            54      ;--- IBRDECOD: INICIO SALTO A DECOD
00001040                            55          ;*** En esta seccion debeis preparar la pila para llamar a la subrutina
00001040                            56          ;*** DECOD, llamar a la subrutina, y vaciar la pila correctamente,
00001040                            57          ;*** almacenando el resultado de la decodificacion en D1
00001040                            58  
00001040                            59              ; ESCRIBID VUESTRO CODIGO AQUI          
00001040                            60  IBREDECOD:
00001040  3F3C 0000                 61      MOVE.W #0,-(A7)         ; preparamos la pila
00001044  3F38 1010                 62      MOVE.W (EIR),-(A7)      ; metemos la instrucción en la pila
00001048                            63      
00001048  4EB9 00001486             64      JSR DECOD               ; saltamos a la subrutina de librería
0000104E                            65                                  ; de decodificación
0000104E                            66                                  
0000104E  544F                      67      ADDQ.W #2,A7            ; sumamos 2 a A7
00001050  321F                      68      MOVE.W (A7)+,D1         ; en D1 tenemos la instrucción a ejecutar
00001052                            69  
00001052                            70          
00001052                            71      ;--- FBRDECOD: FIN SALTO A DECOD
00001052                            72      
00001052                            73      
00001052                            74      
00001052                            75      ;--- IBREXEC: INICIO SALTO A FASE DE EJECUCION
00001052                            76          ;*** Esta seccion se usa para saltar a la fase de ejecucion
00001052                            77          ;*** NO HACE FALTA MODIFICARLA
00001052  C2FC 0006                 78      MULU #6,D1
00001056  2241                      79      MOVEA.L D1,A1
00001058  4EE9 105C                 80      JMP JMPLIST(A1)
0000105C                            81  JMPLIST:
0000105C  4EF9 000010B6             82      JMP ELOA
00001062  4EF9 000010F6             83      JMP ESTO
00001068  4EF9 0000112A             84      JMP ELOIP
0000106E  4EF9 0000116A             85      JMP ESTIP
00001074  4EF9 0000119E             86      JMP EGOI
0000107A  4EF9 000011B0             87      JMP EGOZ
00001080  4EF9 000011CE             88      JMP EGON
00001086  4EF9 000011EC             89      JMP EEXIT
0000108C  4EF9 000011F2             90      JMP ECOPY
00001092  4EF9 0000121A             91      JMP EADD
00001098  4EF9 00001254             92      JMP ESUB
0000109E  4EF9 00001292             93      JMP EAND
000010A4  4EF9 000012CC             94      JMP ESET
000010AA  4EF9 000012F4             95      JMP EADQ
000010B0  4EF9 0000131C             96      JMP ELSH
000010B6                            97      ;--- FBREXEC: FIN SALTO A FASE DE EJECUCION
000010B6                            98      
000010B6                            99      
000010B6                           100      
000010B6                           101      ;--- IEXEC: INICIO EJECUCION
000010B6                           102          ;*** En esta seccion debeis implementar la ejecucion de cada einstr.
000010B6                           103      
000010B6                           104      ; ESCRIBID EN CADA ETIQUETA LA FASE DE EJECUCION DE CADA INSTRUCCION
000010B6                           105  ELOA:                       ; Ti <-- [M]
000010B6  3A38 1010                106      MOVE.W EIR, D5          ; metemos la instr. en D5
000010BA  4EB9 000013A2            107      JSR CogerM              ; sacamaos el valor de M
000010C0  3645                     108      MOVEA.W D5, A3           ; guardamos el valor de M en D6
000010C2                           109      
000010C2  3A6B 1000                110      MOVEA.W EMEM(A3),A5     ; sumamos la dirección de EMemoria + M y la 
000010C6                           111                              ; y la guardamos en A2
000010C6  3A38 1010                112      MOVE.W EIR, D5          ; movemos la inst. a D5, ya que hemos modificado D5
000010CA  4EB9 0000138E            113      JSR CogerI              ; sacamos el valor de I
000010D0  BA7C 0000                114      CMP #0, D5              ; comparamos I con 0              
000010D4  6600 000E                115      BNE I1_Load             ; si no son iguales significa que I es 1, por tanto,
000010D8                           116                              ; saltamos al caso donde I es 1
000010D8  31D5 1014                117      MOVE.W (A5),ET0         ; cuando I es 0, guardamos el contenido de Emem + M
000010DC                           118                              ; en ET0
000010DC  40C2                     119      MOVE.W SR, D2           ; movemos los flags a D2
000010DE  4EF9 000010EA            120      JMP FINAL_Load          ; saltamos al final del ELoad    
000010E4                           121     
000010E4                           122     I1_Load:
000010E4  31D5 1016                123      MOVE.W (A5),ET1
000010E8  40C2                     124      MOVE.W SR, D2           ; movemos los flags a D2
000010EA                           125      
000010EA                           126   FINAL_Load:
000010EA  4244                     127      CLR.W D4                ; limpiamos el registro D4, para modificar los flags
000010EC  4EB9 00001464            128      JSR FLAGS_NZ
000010F2  6000 FF36                129      BRA FETCH            
000010F6                           130  *--------------------------------------------------
000010F6                           131  ESTO:                       ; M <-- [Ti]
000010F6  3A38 1010                132      MOVE.W EIR, D5          ; metemos la instr. en D5
000010FA  4EB9 000013A2            133      JSR CogerM              ; sacamaos el valor de M
00001100  3645                     134      MOVEA.W D5, A3           ; guardamos el valor de M en D6   
00001102                           135      
00001102  346B 1000                136      MOVEA.W EMEM(A3),A2     ; A2 <-- EMEM + M (direcciones de memoria)
00001106                           137   
00001106  3A38 1010                138      MOVE.W EIR, D5          ; metemos la instr. en D5
0000110A  4EB9 0000138E            139      JSR CogerI
00001110  BA7C 0000                140      CMP #0, D5              ; si i = 1 saltamos al caso de ET1
00001114  6600 000C                141      BNE I1_Store            
00001118                           142      
00001118  3478 1014                143      MOVE.W ET0, A2          ; movemos el contenido de ET0 a EMEM + M
0000111C  4EF9 00001126            144      JMP FINAL_Store
00001122                           145      
00001122                           146     I1_Store:
00001122  3478 1016                147      MOVE.W ET1, A2          ; movemos el contenido de ET1 a EMEM + M
00001126                           148    
00001126                           149    FINAL_Store:
00001126  6000 FF02                150      BRA FETCH
0000112A                           151      
0000112A                           152  *--------------------------------------------------
0000112A                           153  ELOIP:                      ; Ti <-- [[Xb]], Xb <-- [Xb] + 1
0000112A  3A38 1010                154      MOVE.W EIR, D5          ; metemos la instr. en D5
0000112E  4EB9 00001374            155      JSR CogerB              ; sacamaos el registro B
00001134  344D                     156      MOVE.W A5, A2           ; guardamos el Rb en A2
00001136                           157      
00001136  3A38 1010                158      MOVE.W EIR, D5          ; metemos la inst. en D5
0000113A  4EB9 0000138E            159      JSR CogerI              ; cogemos I
00001140  BA7C 0000                160      CMP #0, D5              ; comparamos D5(I) con 0
00001144  6600 0010                161      BNE I1_LOIP             ; si no son iguales saltamos donde I = 1
00001148                           162      
00001148  31D2 1014                163      MOVE.W (A2),ET0         ; T0 <-- [[Rb]]
0000114C  40C2                     164      MOVE.W SR, D2           ; guardamos los flags despues de la op.
0000114E  5252                     165      ADD.W #1, (A2)          ; Xb <-- [Xb] + 1   
00001150  4EF9 0000115E            166      JMP FINAL_LOIP
00001156                           167      
00001156                           168     I1_LOIP:
00001156  31D2 1016                169      MOVE.W (A2),ET1         ; T1 <-- [[Rb]]
0000115A  40C2                     170      MOVE.W SR, D2           ; guardamos los flags despues de la op.
0000115C  5252                     171      ADD.W #1, (A2)          ; Xb <-- [Xb] + 1   
0000115E                           172      
0000115E                           173   FINAL_LOIP:
0000115E  4244                     174      CLR.W D4                ; limpiamos D4 por si hay algo, ya que lo 
00001160  4EB9 00001464            175      JSR FLAGS_NZ            ; necesitaremos D4 para actualizar los flags N y Z
00001166                           176      
00001166  6000 FEC2                177      BRA FETCH
0000116A                           178  
0000116A                           179  *--------------------------------------------------
0000116A                           180  ESTIP:                      ; [Xb] <-- [Ti], Xb <-- [Xb] + 1
0000116A  3A38 1010                181      MOVE.W EIR, D5          ; metemos la instr. en D5
0000116E  4EB9 00001374            182      JSR CogerB              ; sacamaos el registro B
00001174  344D                     183      MOVE.W A5, A2           ; guardamos el Rb en A2
00001176                           184      
00001176  3A38 1010                185      MOVE.W EIR, D5          ; metemos la inst. en D5
0000117A  4EB9 0000138E            186      JSR CogerI              ; cogemos I
00001180  BA7C 0000                187      CMP #0, D5              ; comparamos D5(I) con 0
00001184  6600 000E                188      BNE I1_STIP             ; si no son iguales saltamos donde I = 1
00001188                           189      
00001188  34B8 1014                190      MOVE.W (ET0),(A2)       ; [Xb] <-- [T0]
0000118C  5252                     191      ADD.W #1, (A2)          ; Xb <-- [Xb] + 1  
0000118E  4EF9 0000119A            192      JMP FINAL_STIP
00001194                           193      
00001194                           194     I1_STIP:
00001194  34B8 1014                195      MOVE.W (ET0),(A2)       ; [Xb] <-- [T0]
00001198  5252                     196      ADD.W #1, (A2)          ; Xb <-- [Xb] + 1  
0000119A                           197      
0000119A                           198   FINAL_STIP:
0000119A  4EF8 102A                199      JMP FETCH
0000119E                           200  
0000119E                           201  *--------------------------------------------------
0000119E                           202  EGOI:                       ; PC <-- M
0000119E                           203  
0000119E  3A38 1010                204      MOVE.W EIR, D5          ; movemos la instr. a D5
000011A2  4EB9 000013A2            205      JSR CogerM              ; llamamos a la subr. para coger M
000011A8  31C5 1012                206      MOVE.W D5, EPC          ; guardamos D5 en el PC del eprograma
000011AC                           207      
000011AC  6000 FE7C                208      BRA FETCH
000011B0                           209                     
000011B0                           210  *--------------------------------------------------
000011B0                           211  EGOZ:                       ; si Z=1,  PC <-- M
000011B0                           212  
000011B0  3438 1024                213      MOVE.W ESR, D2          ; movemos los eflags a D2
000011B4  0802 0000                214      BTST.L #0, D2           ; comprobamos si el eflag Z es 1
000011B8  6700 0010                215      BEQ Z0                  ; si es 0 saltamos al final de la instr.
000011BC                           216      
000011BC  3A38 1010                217      MOVE.W EIR, D5          ; movemos la instr. a D5
000011C0  4EB9 000013A2            218      JSR CogerM              ; llamamos a la subr. para coger M
000011C6  31C5 1012                219      MOVE.W D5, EPC          ; guardamos D5 en el PC del eprograma
000011CA                           220  
000011CA                           221    Z0:
000011CA  6000 FE5E                222      BRA FETCH    
000011CE                           223      
000011CE                           224  *--------------------------------------------------
000011CE                           225  EGON:                       ; si N=1,  PC <-- M
000011CE                           226  
000011CE  3438 1024                227      MOVE.W ESR, D2          ; movemos los eflags a D2
000011D2  0802 0001                228      BTST.L #1, D2           ; comprobamos si el eflag N es 1
000011D6  6700 0010                229      BEQ N0                  ; si es 0 saltamos al final de la instr.
000011DA                           230      
000011DA  3A38 1010                231      MOVE.W EIR, D5          ; movemos la instr. a D5
000011DE  4EB9 000013A2            232      JSR CogerM              ; llamamos a la subr. para coger M
000011E4  31C5 1012                233      MOVE.W D5, EPC          ; guardamos D5 en el PC del eprograma
000011E8                           234  
000011E8                           235    N0:
000011E8  6000 FE40                236      BRA FETCH    
000011EC                           237      
000011EC                           238  *--------------------------------------------------
000011EC                           239  EEXIT:                      ; Detiene la maquina
000011EC  4EF9 00001554            240      JMP SIMHALT
000011F2                           241  *--------------------------------------------------
000011F2                           242  ECOPY:                      ; Rc <-- Rb
000011F2                           243  
000011F2  3A38 1010                244      MOVE.W EIR, D5          ; movemos la inst. a D5
000011F6  4EB9 00001374            245      JSR CogerB              ; cogemos B
000011FC  344D                     246      MOVE.W A5, A2           ; guardamos B en A2
000011FE                           247      
000011FE  3A38 1010                248      MOVE.W EIR, D5          ; movemos de nuevo la inst. a D5,ya que se modificó
00001202  4EB9 00001382            249      JSR CogerC              ; cogemos C
00001208  324D                     250      MOVE.W A5, A1           ; guardamos C en A1
0000120A                           251      
0000120A  3292                     252      MOVE.W (A2),(A1)        ; copiamos el contenido de A2 dentro de A1
0000120C                           253      
0000120C  40C2                     254      MOVE.W SR, D2           ; copiamos los flags a D2
0000120E  4244                     255      CLR.W D4                ; limpiamos D4 por si hay algo, ya que lo 
00001210  4EB9 00001464            256      JSR FLAGS_NZ            ; necesitaremos D4 para actualizar los flags N y Z
00001216                           257      
00001216  6000 FE12                258      BRA FETCH
0000121A                           259      
0000121A                           260  *--------------------------------------------------
0000121A                           261  EADD:                       ; Rc <-- [Rb] + [Ra]
0000121A                           262  
0000121A  3A38 1010                263      MOVE.W EIR, D5          ; movemos la instr. a D5
0000121E  4EB9 00001366            264      JSR CogerA              ; llamamos a la sub. de usuario para coger el valor
00001224  324D                     265      MOVE.W A5, A1           ; de A y lo movemos a A1
00001226                           266      
00001226  3A38 1010                267      MOVE.W EIR, D5
0000122A  4EB9 00001374            268      JSR CogerB              ; llamamos a la sub. de usuario para coger el valor
00001230  344D                     269      MOVE.W A5, A2           ; de B y lo movemos a A2
00001232                           270      
00001232  3A38 1010                271      MOVE.W EIR, D5
00001236  4EB9 00001382            272      JSR CogerC              ; llamamos a la sub. de usuario para coger el valor
0000123C  364D                     273      MOVE.W A5, A3           ; de C y lo movemos a A3
0000123E                           274      
0000123E  4286                     275      CLR.L D6                ; preparamos D6 para poder poner el resultado
00001240  DC51                     276      ADD.W (A1),D6           ; sumamos el contenido de A1 (A) a D6
00001242  DC52                     277      ADD.W (A2),D6           ; sumamos el contenido de A2 (B) a D6
00001244                           278      
00001244  40C2                     279      MOVE.W SR,D2            ; guardamos los flags del 68k en D2
00001246  4244                     280      CLR.W D4                
00001248  4EB9 00001456            281      JSR Flags_CNZ           ; actualizamos los eflags
0000124E                           282      
0000124E  3686                     283      MOVE.W D6, (A3)         ; movemos el resultado a Rc
00001250                           284      
00001250  6000 FDD8                285      BRA FETCH
00001254                           286  *--------------------------------------------------    
00001254                           287  ESUB:                       ; Rc <-- [Rb] - [Ra]
00001254                           288  
00001254  3A38 1010                289      MOVE.W EIR, D5          ; movemos la instr. a D5
00001258  4EB9 00001366            290      JSR CogerA              ; llamamos a la sub. de usuario para coger el valor
0000125E  324D                     291      MOVE.W A5, A1           ; de A y lo movemos a A1
00001260                           292      
00001260  3A38 1010                293      MOVE.W EIR, D5
00001264  4EB9 00001374            294      JSR CogerB              ; llamamos a la sub. de usuario para coger el valor
0000126A  344D                     295      MOVE.W A5, A2           ; de B y lo movemos a A2
0000126C                           296      
0000126C  3A38 1010                297      MOVE.W EIR, D5
00001270  4EB9 00001382            298      JSR CogerC              ; llamamos a la sub. de usuario para coger el valor
00001276  364D                     299      MOVE.W A5, A3           ; de C y lo movemos a A3
00001278                           300      
00001278  4286                     301      CLR.L D6                ; preparamos D6 para poder poner el resultado
0000127A  DC51                     302      ADD.W (A1),D6           ; sumamos el contenido de A1 (A) a D6
0000127C  4646                     303      NOT.W D6                ; negamos y sumamos 1 a A para hacer una resta
0000127E  5246                     304      ADDQ.W #1, D6
00001280  DC52                     305      ADD.W (A2),D6           ; B + (-A)
00001282                           306  
00001282  40C2                     307      MOVE.W SR,D2            ; guardamos los flags del 68k en D2
00001284  4244                     308      CLR.W D4                ; limpiamos D4
00001286  4EB9 00001456            309      JSR Flags_CNZ           ; actualizamos los eflags
0000128C                           310      
0000128C  3686                     311      MOVE.W D6, (A3)         ; movemos el resultado a Rc
0000128E                           312      
0000128E  6000 FD9A                313      BRA FETCH
00001292                           314  *--------------------------------------------------    
00001292                           315  EAND:                       ; Rc <-- [Rb] and [Ra]
00001292                           316  
00001292  3A38 1010                317      MOVE.W EIR, D5          ; movemos la instr. a D5
00001296  4EB9 00001366            318      JSR CogerA              ; llamamos a la sub. de usuario para coger el valor
0000129C  324D                     319      MOVE.W A5, A1           ; de A y lo movemos a A1
0000129E                           320      
0000129E  3A38 1010                321      MOVE.W EIR, D5
000012A2  4EB9 00001374            322      JSR CogerB              ; llamamos a la sub. de usuario para coger el valor
000012A8  344D                     323      MOVE.W A5, A2           ; de B y lo movemos a A2
000012AA                           324      
000012AA  3A38 1010                325      MOVE.W EIR, D5
000012AE  4EB9 00001382            326      JSR CogerC              ; llamamos a la sub. de usuario para coger el valor
000012B4  364D                     327      MOVE.W A5, A3           ; de C y lo movemos a A3
000012B6                           328  
000012B6  3C11                     329      MOVE.W (A1),D6          ; movemos A y B a los registros de dat.
000012B8  3E12                     330      MOVE.W (A2),D7
000012BA  CC47                     331      AND.W   D7 ,D6          ; A and B
000012BC                           332      
000012BC  40C2                     333      MOVE.W SR,D2            ; guardamos los flags del 68k en D2
000012BE  4244                     334      CLR.W D4                ; limpiamos D4 
000012C0  4EB9 00001464            335      JSR Flags_NZ            ; actualizamos los eflags
000012C6                           336      
000012C6  3686                     337      MOVE.W D6, (A3)         ; movemos el resultado a Rc
000012C8                           338      
000012C8  6000 FD60                339      BRA FETCH
000012CC                           340  *--------------------------------------------------
000012CC                           341  ESET:                       ; Rc <-- k (ext. signo)
000012CC  3A38 1010                342      MOVE.W EIR, D5          ; movemos la instr. a D5
000012D0  4EB9 00001382            343      JSR CogerC              ; llamamos a la sub. de usuario para coger el valor
000012D6  364D                     344      MOVE.W A5, A3           ; de C y lo movemos a A3
000012D8                           345      
000012D8  3A38 1010                346      MOVE.W EIR, D5          ; movemos la instr. a D5
000012DC  4EB9 000013AA            347      JSR CogerK              ; cogemos k (dentro se realiza la ext. de signo)
000012E2  3C05                     348      MOVE.W D5, D6           ; guardamos k en D6
000012E4                           349      
000012E4  3686                     350      MOVE.W D6,(A3)          ; guardamos D6 (k) dentro de A3 (C)
000012E6                           351      
000012E6  40C2                     352      MOVE.W SR,D2            ; guardamos los flags del 68k en D2
000012E8  4244                     353      CLR.W D4                ; limpiamos D4 por si hay algo, ya que lo 
000012EA  4EB9 00001464            354      JSR FLAGS_NZ            ; necesitaremos D4 para actualizar los flags N y Z
000012F0                           355  
000012F0  6000 FD38                356      BRA FETCH
000012F4                           357  
000012F4                           358  *--------------------------------------------------
000012F4                           359  EADQ:                       ; Rc <-- [Rc] + k (ext. signo)
000012F4  3A38 1010                360      MOVE.W EIR, D5          ; movemos la instr. a D5
000012F8  4EB9 00001382            361      JSR CogerC              ; llamamos a la sub. de usuario para coger el valor
000012FE  364D                     362      MOVE.W A5, A3           ; de C y lo movemos a A3
00001300                           363      
00001300  3A38 1010                364      MOVE.W EIR, D5          ; movemos la instr. a D5
00001304  4EB9 000013AA            365      JSR CogerK              ; cogemos k (dentro se realiza la ext. de signo)
0000130A  3C05                     366      MOVE.W D5, D6           ; guardamos k en D6
0000130C                           367      
0000130C  DD53                     368      ADD.W D6,(A3)           ; sumamos D6 (k) con A3(C) y lo guardamos en A3(C)
0000130E                           369      
0000130E  40C2                     370      MOVE.W SR,D2            ; guardamos los flags del 68k en D2
00001310  4244                     371      CLR.W D4                ; limpiamos D4 por si hay algo, ya que lo 
00001312  4EB9 00001456            372      JSR FLAGS_CNZ           ; necesitaremos D4 para actualizar todos los eflags
00001318                           373  
00001318  6000 FD10                374      BRA FETCH
0000131C                           375  *--------------------------------------------------
0000131C                           376  ELSH:                       ; si n=0 => Rb <-- [Rb] left shift p
0000131C                           377                              ; si n=1 => Rb <-- [Rb] right shift p
0000131C  3A38 1010                378      MOVE.W EIR, D5          ; movemos la inst. a D5
00001320  4EB9 00001374            379      JSR CogerB              ; cogemos el registro B
00001326  344D                     380      MOVE.W A5, A2           ; guardamos el Rb en A2
00001328  3E12                     381      MOVE.W (A2),D7          ; movemos el contenido de A2(B) a un registro
0000132A                           382                              ; temporal
0000132A                           383      
0000132A  3A38 1010                384      MOVE.W EIR, D5          ; movemos la inst. a D5
0000132E  4EB9 0000139A            385      JSR CogerP              ; cogemos P
00001334  3C05                     386      MOVE.W D5, D6           ; guardamos D5(P) en D6
00001336                           387  
00001336  3A38 1010                388      MOVE.W EIR, D5          ; movemos la intsrucción a D5
0000133A  4EB9 00001394            389      JSR CogerN              ; cogemos el valor de N
00001340  BA7C 0000                390      CMP #0, D5              ; comparamos 0 con N
00001344  6600 000E                391      BNE RShift              ; si N es 1 saltamos a right shift
00001348                           392      
00001348  ED6F                     393      LSL.W D6 , D7           ; n=0, por tanto hacemos un LSL con desp. D6(P)
0000134A  40C2                     394      MOVE.W SR, D2           ; guardamos los flags después de la operación
0000134C  3447                     395      MOVE.W D7, A2           ; guardamos el resultado en A2(B)
0000134E  4EF9 0000135A            396      JMP FINAL_LSH           ; saltamos al final
00001354                           397      
00001354                           398     RShift:
00001354  EC6F                     399      LSR.W D6, D7            ; n=1, por tanto hacemos un LSR con desp. D6(P)
00001356  40C2                     400      MOVE.W SR, D2           ; guardamos los flags 
00001358  3447                     401      MOVE.W D7, A2           ; guardamos el resultado en A2(B)
0000135A                           402      
0000135A                           403   FINAL_LSH:
0000135A  4244                     404      CLR.W D4                ; limpiamos D4 porque lo utilizamos para actualizar
0000135C  4EB9 00001456            405      JSR FLAGS_CNZ           ; los flags CNZ
00001362                           406      
00001362  6000 FCC6                407      BRA FETCH
00001366                           408      
00001366                           409  *--------------------------------------------------
00001366                           410      ;--- FEXEC: FIN EJECUCION
00001366                           411      
00001366                           412      
00001366                           413  
00001366                           414      ;--- ISUBR: INICIO SUBRUTINAS
00001366                           415          ;*** Aqui debeis incluir las subrutinas que necesite vuestra solucion
00001366                           416          ;*** SALVO DECOD, que va en la siguiente seccion
00001366                           417  
00001366                           418              ; ESCRIBID VUESTRO CODIGO AQUI
00001366                           419              
00001366                           420  CogerA:
00001366  E08D                     421      LSR.L #8,D5             ; movemos D5 8 posiciones a la derecha
00001368  CA7C 0007                422      AND.W #$0007,D5         ; con una máscara, cogemos el valor de A (aaa)
0000136C                           423      
0000136C  4EB9 000013B4            424      JSR REGISTROS           ; miramos a qué registro se corresponde
00001372                           425      
00001372  4E75                     426      RTS
00001374                           427      
00001374                           428      
00001374                           429  CogerB:
00001374  E88D                     430      LSR.L #4,D5             ; movemos D5 4 posiciones a la derecha
00001376  CA7C 0007                431      AND.W #$0007,D5         ; con una máscara, cogemos el valor de B (bbb)
0000137A                           432      
0000137A  4EB9 000013B4            433      JSR REGISTROS           ; miramos a qué registro se corresponde
00001380                           434      
00001380  4E75                     435      RTS
00001382                           436  
00001382                           437  
00001382                           438  CogerC:
00001382  CA7C 0007                439      AND.W #$0007,D5         ; con una máscara, cogemos el valor de C (ccc)
00001386                           440  
00001386  4EB9 000013B4            441      JSR REGISTROS           ; miramos a qué registro se corresponde
0000138C                           442      
0000138C  4E75                     443      RTS
0000138E                           444     
0000138E                           445  CogerI:
0000138E  CA7C 0001                446      AND.W #0001,D5          ; con una máscara, cogemos el valor de I
00001392                           447      
00001392  4E75                     448      RTS
00001394                           449      
00001394                           450  CogerN:
00001394  CA7C 0001                451      AND.W #0001,D5          ; con una máscara, cogemos el valor de N
00001398                           452      
00001398  4E75                     453      RTS
0000139A                           454      
0000139A                           455  CogerP:
0000139A  E08D                     456      LSR.L #8,D5             ; movemos D5 8 posiciones a la derecha
0000139C  CA7C 0007                457      AND.W #0007,D5          ; con una máscara, cogemos el valor de P (ppp)
000013A0                           458      
000013A0  4E75                     459      RTS
000013A2                           460      
000013A2                           461  CogerM:
000013A2  E28D                     462      LSR.L #1,D5             ; movemos D5 4 posiciones a la derecha
000013A4  CA7C 00FF                463      AND.W #$00FF,D5         ; con una máscara, cogemos el valor de M (mmmmmmmm)
000013A8                           464      
000013A8  4E75                     465      RTS
000013AA                           466     
000013AA                           467  CogerK:
000013AA  E68D                     468      LSR.L #3,D5             ; movemos D5 3 posiciones a la derecha
000013AC  CA3C 00FF                469      AND.B #$00FF,D5         ; con una máscara, cogemos el valor de K (kkkkkkkk)
000013B0  4885                     470      EXT.W D5                ; hacemos una extensión de signo (byte -> word)
000013B2                           471      
000013B2  4E75                     472      RTS
000013B4                           473  
000013B4                           474  *--------------------------------------
000013B4                           475  
000013B4                           476  REGISTROS:
000013B4  0805 0002                477      BTST.L #2,D5            ; miramos el tercer bit del registro
000013B8  6600 0026                478      BNE REGISTROS_1XX       ; si no es 0, saltamos para mirar el registro 1XX
000013BC                           479      
000013BC                           480     ;0XX
000013BC  0805 0001                481      BTST.L #1,D5            ; miramos el segundo bit del registro
000013C0  6600 0010                482      BNE REGISTROS_01X       ; si no es 0, saltamos para mirar el registro 01X
000013C4                           483      
000013C4                           484          ;00X
000013C4  0805 0000                485           BTST.L #0,D5       ; miramos el primer bit del registro
000013C8  6700 003A                486           BEQ REGISTRO_T0    ; si es 0, el registro es B0
000013CC  4EF9 0000140E            487           JMP REGISTRO_T1    ; si es 0, el registro es B1
000013D2                           488      
000013D2                           489          REGISTROS_01X:
000013D2  0805 0000                490           BTST.L #0,D5       ; miramos el primer bit del registro
000013D6  6700 0040                491           BEQ REGISTRO_X2    ; si es 0, el registro es R2
000013DA  4EF9 00001422            492           JMP REGISTRO_X3    ; si es 0, el registro es R3
000013E0                           493      
000013E0                           494     REGISTROS_1XX:
000013E0  0805 0001                495      BTST.L #1,D5            ; miramos el segundo bit del registro
000013E4  6600 0010                496      BNE REGISTROS_11X       ; si no es 0, saltamos para mirar el registro 11X
000013E8                           497      
000013E8                           498          ;10X
000013E8  0805 0000                499           BTST.L #0,D5       ; miramos el primer bit del registro
000013EC  6700 003E                500           BEQ REGISTRO_X4    ; si es 0, el registro es R4
000013F0  4EF9 00001436            501           JMP REGISTRO_X5    ; si es 0, el registro es R5
000013F6                           502      
000013F6                           503          REGISTROS_11X:
000013F6  0805 0000                504           BTST.L #0,D5       ; miramos el primer bit del registro
000013FA  6700 0044                505           BEQ REGISTRO_X6    ; si es 0, el registro es T6
000013FE  4EF9 0000144A            506           JMP REGISTRO_X7    ; si es 0, el registro es T7
00001404                           507      
00001404                           508  
00001404                           509    ; A partir de aquí guardamos las direcciones y salimos de la subrutina 
00001404                           510     REGISTRO_T0:
00001404  4BF8 1014                511      LEA.L ET0,A5            ; guardamos el contenido de ET0 en A5
00001408  4EF9 00001454            512      JMP FIN_REGISTROS       ; saltamos al final de la subrutina de registros
0000140E                           513      
0000140E                           514     REGISTRO_T1:
0000140E  4BF8 1016                515      LEA.L ET1,A5            ; guardamos el contenido de ET1 en A5
00001412  4EF9 00001454            516      JMP FIN_REGISTROS       ; saltamos al final de la subrutina de registros
00001418                           517      
00001418                           518     REGISTRO_X2:
00001418  4BF8 1018                519      LEA.L EX2,A5            ; guardamos el contenido de EX2 en A5
0000141C  4EF9 00001454            520      JMP FIN_REGISTROS       ; saltamos al final de la subrutina de registros
00001422                           521      
00001422                           522     REGISTRO_X3:
00001422  4BF8 101A                523      LEA.L EX3,A5            ; guardamos el contenido de EX3 en A5
00001426  4EF9 00001454            524      JMP FIN_REGISTROS       ; saltamos al final de la subrutina de registros
0000142C                           525      
0000142C                           526     REGISTRO_X4:
0000142C  4BF8 101C                527      LEA.L EX4,A5            ; guardamos el contenido de EX4 en A5
00001430  4EF9 00001454            528      JMP FIN_REGISTROS       ; saltamos al final de la subrutina de registros
00001436                           529      
00001436                           530     REGISTRO_X5:
00001436  4BF8 101E                531      LEA.L EX5,A5            ; guardamos el contenido de EX5 en A5
0000143A  4EF9 00001454            532      JMP FIN_REGISTROS       ; saltamos al final de la subrutina de registros
00001440                           533      
00001440                           534     REGISTRO_X6:
00001440  4BF8 1020                535      LEA.L EX6,A5            ; guardamos el contenido de EX6 en A5
00001444  4EF9 00001454            536      JMP FIN_REGISTROS       ; saltamos al final de la subrutina de registros
0000144A                           537      
0000144A                           538     REGISTRO_X7:
0000144A  4BF8 1022                539      LEA.L EX7,A5            ; guardamos el contenido de EX7 en A5
0000144E  4EF9 00001454            540      JMP FIN_REGISTROS       ; saltamos al final de la subrutina de registros
00001454                           541      
00001454                           542     FIN_REGISTROS: 
00001454  4E75                     543      RTS
00001456                           544  *--------------------------------------
00001456                           545  ; Flags 68k = NZVC, FLAGS HAL9000 = 0CNZ  
00001456                           546  
00001456                           547  FLAGS_CNZ:
00001456  3602                     548      MOVE D2,D3              ; copiamos los flags para poder manipularlos
00001458  0803 0000                549      BTST.L #0,D3            ; miramos C
0000145C  6700 0006                550      BEQ FLAGS_NZ            ; si C es 0, saltamos a mirar el flag Z
00001460                           551      
00001460  08C4 0002                552      BSET.L #2,D4              ; si no es 0, pondremos a 1 el valor de C en D4
00001464                           553      
00001464                           554  *--------------------------------------    
00001464                           555  FLAGS_NZ:
00001464  3602                     556      MOVE.W D2,D3            ; copiamos los flags para poder manipularlos
00001466  0803 0003                557      BTST.L #3,D3            ; miramos N
0000146A  6700 0006                558      BEQ FLAG_Z              ; si N es 0, saltamos a mirar el siguiente flag
0000146E                           559      
0000146E  08C4 0001                560      BSET.L #1,D4            ; si no es 0, pondremos a 1 el valor de N en D4
00001472                           561      
00001472                           562     FLAG_Z:
00001472  3602                     563      MOVE.W D2,D3            ; copiamos los flags para poder manipularlos
00001474  0803 0002                564      BTST.L #2,D3            ; miramos Z
00001478  6700 0006                565      BEQ FINAL_FLAGS         ; si Z es 0, saltamos al final de los flags
0000147C                           566      
0000147C  08C4 0000                567      BSET.L #0,D4            ; si no es 0, pondremos a 1 el valor de Z en D4
00001480                           568      
00001480                           569     FINAL_FLAGS:
00001480  31C4 1024                570      MOVE.W D4,ESR           ; movemos D4 (flags finales) a ESR, los eflags
00001484  4E75                     571      RTS
00001486                           572          
00001486                           573          
00001486                           574      ;--- FSUBR: FIN SUBRUTINAS
00001486                           575      
00001486                           576      
00001486                           577  
00001486                           578      ;--- IDECOD: INICIO DECOD
00001486                           579          ;*** Tras la etiqueta DECOD, debeis implementar la subrutina de 
00001486                           580          ;*** decodificacion, que debera ser de libreria, siguiendo la interfaz
00001486                           581          ;*** especificada en el enunciado
00001486                           582  DECOD:
00001486                           583              ; ESCRIBID VUESTRO CODIGO AQUI
00001486                           584              
00001486  3F00                     585      MOVE.W D0,-(A7)         ; guardamos D0 en la pila
00001488  3F01                     586      MOVE.W D1,-(A7)         ; guardamos D1 en la pila
0000148A  302F 0008                587      MOVE.W 8(A7),D0         ; la instrucción que hemos guardado la pasamos a D0
0000148E                           588  
0000148E  323C 0000                589      MOVE.W #0, D1           ; D1 contiene el id de la instrucción
00001492  0800 000F                590      BTST.L #15, D0          ; miramos el bit 16º de la instr.
00001496  6600 0050                591      BNE DECOD_1XXX          ; si no es 0, saltamos a para la instr. 1XXX
0000149A                           592      
0000149A                           593      ;0XXX
0000149A  0800 000E                594      BTST.L #14, D0          ; miramos el bit 15º de la instr.
0000149E  6600 0028                595      BNE DECOD_01XX          ; si no es 0, saltamos a para la instr. 01XX
000014A2                           596  
000014A2                           597          ;00XX
000014A2  0800 000D                598          BTST.L #13, D0      ; miramos el bit 14º de la instr.
000014A6  6600 0010                599          BNE DECOD_001X      ; si no es 0, saltamos a para la instr. 001X
000014AA                           600          
000014AA                           601              ;000X
000014AA  0800 000C                602              BTST.L #12, D0  ; miramos el bit 13º de la instr.
000014AE  6600 0098                603              BNE FINAL_AUX   ; si no es 0, saltamos a final aux para sumar 1
000014B2  4EF9 0000154A            604              JMP FINAL       ; si es 0, saltamos al final
000014B8                           605              
000014B8                           606            DECOD_001X:
000014B8  5441                     607              ADDQ.W #2, D1   ; sumamos 2 al id de la instr.
000014BA  0800 000C                608              BTST.L #12, D0  ; miramos el bit 13º de la instr.  
000014BE  6600 0088                609              BNE FINAL_AUX   ; si no es 0, saltamos a final aux para sumar 1
000014C2  4EF9 0000154A            610              JMP FINAL       ; si es 0, saltamos al final
000014C8                           611           
000014C8                           612        DECOD_01XX:
000014C8  5841                     613          ADDQ.W #4, D1       ; sumamos 4 al id de la instr.
000014CA  0800 000D                614          BTST.L #13, D0      ; miramos el bit 14º de la instr.
000014CE  6600 0010                615          BNE DECOD_0110      ; si no es 0, saltamos a la única otra 
000014D2                           616                              ; posibilidad que es 0110
000014D2                           617             ;010X
000014D2  0800 000C                618             BTST.L #12, D0   ; miramos el bit 13º de la instr.
000014D6  6600 0070                619             BNE FINAL_AUX    ; si no es 0, saltamos a final aux para sumar 1
000014DA  4EF9 0000154A            620             JMP FINAL        ; si es 0, saltamos directamente al final
000014E0                           621        
000014E0                           622        DECOD_0110:
000014E0  5C41                     623          ADDQ.W #6, D1       ; sumamos 6 directamente porque solo hay 1 instr.
000014E2  4EF9 0000154A            624          JMP FINAL           ; que empiece por 011
000014E8                           625          
000014E8                           626    DECOD_1XXX:
000014E8  5E41                     627      ADDQ.W #7, D1           ; id = 7
000014EA  0800 000E                628      BTST.L #14, D0          ; miramos el bit 15º de la instr.
000014EE  6600 0008                629      BNE DECOD_11XXX         ; si no es 0, saltamos a la instr. 10XXX
000014F2  4EF9 0000154A            630      JMP FINAL               ; como la única instr. con 10 sumamos el id
000014F8                           631                              ; y saltamos directamente al final
000014F8                           632          
000014F8                           633        
000014F8                           634    DECOD_11XXX:
000014F8  0800 000D                635      BTST.L #13, D0          ; miramos el bit 14º 
000014FC  6600 002A                636      BNE DECOD_111XX         ; si no es 0, saltamos a 111XX
00001500                           637      
00001500                           638          ;110XX
00001500  0800 000C                639          BTST.L #12, D0      ; miramos el bit 13º
00001504  6600 0012                640          BNE DECOD_1101X
00001508                           641          
00001508                           642              ;1100X
00001508  5241                     643              ADDQ.W #1, D1   ; id = 8
0000150A  0800 000B                644              BTST.L #11, D0  ; miramos el bit 12º 
0000150E  6600 0038                645              BNE FINAL_AUX   ; si es 1, saltamos al final aux para sumar 1
00001512  4EF9 0000154A            646              JMP FINAL       ; si es 0, saltamos directamente al final
00001518                           647  
00001518                           648  
00001518                           649             DECOD_1101X:
00001518  5641                     650              ADDQ.W #3, D1   ; id = 10
0000151A  0800 000B                651              BTST.L #11, D0  ; miramos el bit 12º
0000151E  6600 0028                652              BNE FINAL_AUX   ; si es 1, saltamos al final aux para sumar 1
00001522  4EF9 0000154A            653              JMP FINAL       ; si es 0, saltamos directamente al final
00001528                           654        
00001528                           655        DECOD_111XX:
00001528  5A41                     656          ADDQ.W #5, D1       ; id = 12
0000152A  0800 000C                657          BTST.L #12, D0      ; miramos el bit 13º
0000152E  6600 0010                658          BNE DECOD_11110     ; si es 1, saltamos a 11110
00001532                           659          
00001532                           660              ;11100
00001532  0800 000B                661              BTST.L #11, D0  ; miramos el bit 12º
00001536  6600 0010                662              BNE FINAL_AUX   ; si es 1, sumamos 1 al id
0000153A  4EF9 0000154A            663              JMP FINAL       ; si es 0, saltamos al final
00001540                           664              
00001540                           665            DECOD_11110:
00001540  5441                     666              ADDQ.W #2, D1   ; id = 14
00001542  4EF9 0000154A            667              JMP FINAL
00001548                           668  
00001548                           669     FINAL_AUX:
00001548  5241                     670      ADDQ.W #1,D1            ; sumamos 1 al id
0000154A                           671      
0000154A                           672     FINAL: 
0000154A  3F41 000A                673      MOVE.W D1,10(A7)        ; guardamos el id en la pila
0000154E  321F                     674      MOVE.W (A7)+,D1         ; sacamos D1 de la pila
00001550  301F                     675      MOVE.W (A7)+,D0         ; sacamos D0 de la pila
00001552                           676      
00001552  4E75                     677      RTS
00001554                           678  
00001554                           679  
00001554                           680      ;--- FDECOD: FIN DECOD
00001554                           681      
00001554                           682  SIMHALT:
00001554  FFFF FFFF                683      SIMHALT                 ; detiene la máquina
00001558                           684      END    START

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
COGERA              1366
COGERB              1374
COGERC              1382
COGERI              138E
COGERK              13AA
COGERM              13A2
COGERN              1394
COGERP              139A
DECOD               1486
DECOD_001X          14B8
DECOD_0110          14E0
DECOD_01XX          14C8
DECOD_1101X         1518
DECOD_11110         1540
DECOD_111XX         1528
DECOD_11XXX         14F8
DECOD_1XXX          14E8
EADD                121A
EADQ                12F4
EAND                1292
ECOPY               11F2
EEXIT               11EC
EGOI                119E
EGON                11CE
EGOZ                11B0
EIR                 1010
ELOA                10B6
ELOIP               112A
ELSH                131C
EMEM                1000
EPC                 1012
ESET                12CC
ESR                 1024
ESTIP               116A
ESTO                10F6
ESUB                1254
ET0                 1014
ET1                 1016
EX2                 1018
EX3                 101A
EX4                 101C
EX5                 101E
EX6                 1020
EX7                 1022
FETCH               102A
FINAL               154A
FINAL_AUX           1548
FINAL_FLAGS         1480
FINAL_LOAD          10EA
FINAL_LOIP          115E
FINAL_LSH           135A
FINAL_STIP          119A
FINAL_STORE         1126
FIN_REGISTROS       1454
FLAGS_CNZ           1456
FLAGS_NZ            1464
FLAG_Z              1472
I1_LOAD             10E4
I1_LOIP             1156
I1_STIP             1194
I1_STORE            1122
IBREDECOD           1040
JMPLIST             105C
N0                  11E8
REGISTROS           13B4
REGISTROS_01X       13D2
REGISTROS_11X       13F6
REGISTROS_1XX       13E0
REGISTRO_T0         1404
REGISTRO_T1         140E
REGISTRO_X2         1418
REGISTRO_X3         1422
REGISTRO_X4         142C
REGISTRO_X5         1436
REGISTRO_X6         1440
REGISTRO_X7         144A
RSHIFT              1354
SIMHALT             1554
START               1026
Z0                  11CA
