00001026 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 19/05/2023 23:04:27

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : PRAFIN23
00000000                             3  * Written by : <nombres completos de los autores>
00000000                             4  * Date       : 19/05/2023
00000000                             5  * Description: Emulador de la HAL9000
00000000                             6  
00000000                             7  * Dudas = 
00000000                             8  * -(instrucciones ADD) cuando coges un reg y lo sumas
00000000                             9  *   hay que hacer (A1) o A1
00000000                            10  * - instrucciones LOIP y STIP  ¿Xb <-- [Xb] + 1? ¿es pila?
00000000                            11  * - Diferencia entre SET y ADQ solo move en vez de add? 
00000000                            12  *-----------------------------------------------------------
00001000                            13      ORG $1000
00001000= 000F C012 400A D...       14  EMEM:   DC.W $000F,$C012,$400A,$D222,$8000,$CA22,$8000,$0001
00001010= 0000                      15  EIR:    DC.W 0 ;eregistro de instruccion
00001012= 0000                      16  EPC:    DC.W 0 ;econtador de programa
00001014= 0000                      17  ET0:    DC.W 0 ;eregistro T0
00001016= 0000                      18  ET1:    DC.W 0 ;eregistro T1
00001018= 0000                      19  EX2:    DC.W 0 ;eregistro X2
0000101A= 0000                      20  EX3:    DC.W 0 ;eregistro X3
0000101C= 0000                      21  EX4:    DC.W 0 ;eregistro X4
0000101E= 0000                      22  EX5:    DC.W 0 ;eregistro X5
00001020= 0000                      23  EX6:    DC.W 0 ;eregistro X6
00001022= 0000                      24  EX7:    DC.W 0 ;eregistro X7
00001024= 0000                      25  ESR:    DC.W 0 ;eregistro de estado (00000000 00000CNZ)
00001026                            26  START:
00001026  4278 1012                 27      CLR.W EPC
0000102A                            28  
0000102A                            29  FETCH:
0000102A                            30      ;--- IFETCH: INICIO FETCH
0000102A                            31          ;*** En esta seccion debeis introducir el codigo necesario para cargar
0000102A                            32          ;*** en el EIR la siguiente instruccion a ejecutar, indicada por el EPC,
0000102A                            33          ;*** y dejar listo el EPC para que apunte a la siguiente instruccion
0000102A                            34      
0000102A                            35              ; ESCRIBID VUESTRO CODIGO AQUI      
0000102A                            36          
0000102A  3038 1012                 37      MOVE.W EPC,D0           ; movemos el contador a D0
0000102E  C0FC 0002                 38      MULU.W #2,D0            ; multiplicamos x2 D0
00001032                            39      
00001032  41F8 1000                 40      LEA.L EMEM,A0           ; cogemos la dirección de la memoria
00001036  D0C0                      41      ADD.W D0,A0             ; sumamos D0 (PC) a A0 para tener la dirección de
00001038                            42                                  ; la instrucción a ejecutar
00001038                            43      
00001038  5278 1012                 44      ADD.W #1,EPC            ; sumamos 1 al EPC para ya apuntar a la siguiente
0000103C  31D0 1010                 45      MOVE.W (A0),EIR         ; movemos la instrucción al eregistro
00001040                            46                                  ; de instrucción
00001040                            47      
00001040                            48          
00001040                            49      ;--- FFETCH: FIN FETCH
00001040                            50      
00001040                            51      
00001040                            52      
00001040                            53      ;--- IBRDECOD: INICIO SALTO A DECOD
00001040                            54          ;*** En esta seccion debeis preparar la pila para llamar a la subrutina
00001040                            55          ;*** DECOD, llamar a la subrutina, y vaciar la pila correctamente,
00001040                            56          ;*** almacenando el resultado de la decodificacion en D1
00001040                            57  
00001040                            58              ; ESCRIBID VUESTRO CODIGO AQUI          
00001040                            59  IBREDECOD:
00001040  3F3C 0000                 60      MOVE.W #0,-(A7)         ; preparamos la pila
00001044  3F38 1010                 61      MOVE.W (EIR),-(A7)      ; metemos la instrucción en la pila
00001048                            62      
00001048  4EB9 000014B2             63      JSR DECOD               ; saltamos a la subrutina de librería
0000104E                            64                                  ; de decodificación
0000104E                            65                                  
0000104E  544F                      66      ADDQ.W #2,A7            ; sumamos 2 a A7
00001050  321F                      67      MOVE.W (A7)+,D1         ; en D1 tenemos la instrucción a ejecutar
00001052                            68  
00001052                            69          
00001052                            70      ;--- FBRDECOD: FIN SALTO A DECOD
00001052                            71      
00001052                            72      
00001052                            73      
00001052                            74      ;--- IBREXEC: INICIO SALTO A FASE DE EJECUCION
00001052                            75          ;*** Esta seccion se usa para saltar a la fase de ejecucion
00001052                            76          ;*** NO HACE FALTA MODIFICARLA
00001052  C2FC 0006                 77      MULU #6,D1
00001056  2241                      78      MOVEA.L D1,A1
00001058  4EE9 105C                 79      JMP JMPLIST(A1)
0000105C                            80  JMPLIST:
0000105C  4EF9 000010B6             81      JMP ELOA
00001062  4EF9 000010FA             82      JMP ESTO
00001068  4EF9 0000112E             83      JMP ELOIP
0000106E  4EF9 00001182             84      JMP ESTIP
00001074  4EF9 000011CA             85      JMP EGOI
0000107A  4EF9 000011DC             86      JMP EGOZ
00001080  4EF9 000011FA             87      JMP EGON
00001086  4EF9 00001218             88      JMP EEXIT
0000108C  4EF9 0000121E             89      JMP ECOPY
00001092  4EF9 00001246             90      JMP EADD
00001098  4EF9 00001280             91      JMP ESUB
0000109E  4EF9 000012BE             92      JMP EAND
000010A4  4EF9 000012F8             93      JMP ESET
000010AA  4EF9 00001320             94      JMP EADQ
000010B0  4EF9 00001348             95      JMP ELSH
000010B6                            96      ;--- FBREXEC: FIN SALTO A FASE DE EJECUCION
000010B6                            97      
000010B6                            98      
000010B6                            99      
000010B6                           100      ;--- IEXEC: INICIO EJECUCION
000010B6                           101          ;*** En esta seccion debeis implementar la ejecucion de cada einstr.
000010B6                           102      
000010B6                           103      ; ESCRIBID EN CADA ETIQUETA LA FASE DE EJECUCION DE CADA INSTRUCCION
000010B6                           104  ELOA:                       ; Ti <-- [M]
000010B6  3A38 1010                105      MOVE.W EIR, D5          ; metemos la instr. en D5
000010BA  4EB9 000013CE            106      JSR CogerM              ; sacamaos el valor de M
000010C0  CAFC 0002                107      MULU.W #2, D5
000010C4  D7C5                     108      ADDA.L D5, A3          ; guardamos el valor de M en D6
000010C6                           109      
000010C6  3C2B 1000                110      MOVE.W EMEM(A3),D6     ; sumamos la dirección de EMemoria + M y la 
000010CA                           111                              ; y la guardamos en A2
000010CA  3A38 1010                112      MOVE.W EIR, D5          ; movemos la inst. a D5, ya que hemos modificado D5
000010CE  4EB9 000013BA            113      JSR CogerI              ; sacamos el valor de I
000010D4  BA7C 0000                114      CMP #0, D5              ; comparamos I con 0              
000010D8  6600 000E                115      BNE I1_Load             ; si no son iguales significa que I es 1, por tanto,
000010DC                           116                              ; saltamos al caso donde I es 1
000010DC  31C6 1014                117      MOVE.W D6,ET0         ; cuando I es 0, guardamos el contenido de Emem + M
000010E0                           118                              ; en ET0
000010E0  40C2                     119      MOVE.W SR, D2           ; movemos los flags a D2
000010E2  4EF9 000010EE            120      JMP FINAL_Load          ; saltamos al final del ELoad    
000010E8                           121     
000010E8                           122     I1_Load:
000010E8  31C6 1016                123      MOVE.W D6,ET1
000010EC  40C2                     124      MOVE.W SR, D2           ; movemos los flags a D2
000010EE                           125      
000010EE                           126   FINAL_Load:
000010EE  4244                     127      CLR.W D4                ; limpiamos el registro D4, para modificar los flags
000010F0  4EB9 00001490            128      JSR FLAGS_NZ
000010F6  6000 FF32                129      BRA FETCH            
000010FA                           130  *--------------------------------------------------
000010FA                           131  ESTO:                       ; M <-- [Ti]
000010FA  3A38 1010                132      MOVE.W EIR, D5          ; metemos la instr. en D5
000010FE  4EB9 000013CE            133      JSR CogerM              ; sacamaos el valor de M
00001104  3645                     134      MOVEA.W D5, A3           ; guardamos el valor de M en D6   
00001106                           135      
00001106  346B 1000                136      MOVEA.W EMEM(A3),A2     ; A2 <-- EMEM + M (direcciones de memoria)
0000110A                           137   
0000110A  3A38 1010                138      MOVE.W EIR, D5          ; metemos la instr. en D5
0000110E  4EB9 000013BA            139      JSR CogerI
00001114  BA7C 0000                140      CMP #0, D5              ; si i = 1 saltamos al caso de ET1
00001118  6600 000C                141      BNE I1_Store            
0000111C                           142      
0000111C  3478 1014                143      MOVE.W ET0, A2          ; movemos el contenido de ET0 a EMEM + M
00001120  4EF9 0000112A            144      JMP FINAL_Store
00001126                           145      
00001126                           146     I1_Store:
00001126  3478 1016                147      MOVE.W ET1, A2          ; movemos el contenido de ET1 a EMEM + M
0000112A                           148    
0000112A                           149    FINAL_Store:
0000112A  6000 FEFE                150      BRA FETCH
0000112E                           151      
0000112E                           152  *--------------------------------------------------
0000112E                           153  ELOIP:                      ; Ti <-- [[Xb]], Xb <-- [Xb] + 1
0000112E  3A38 1010                154      MOVE.W EIR, D5          ; metemos la instr. en D5
00001132  4EB9 000013A0            155      JSR CogerB              ; sacamaos el registro B
00001138  344D                     156      MOVE.W A5, A2           ; guardamos el Xb en A2
0000113A                           157      
0000113A  3A38 1010                158      MOVE.W EIR, D5          ; metemos la inst. en D5
0000113E  4EB9 000013BA            159      JSR CogerI              ; cogemos I
00001144  BA7C 0000                160      CMP #0, D5              ; comparamos D5(I) con 0
00001148  6600 001A                161      BNE I1_LOIP             ; si no son iguales saltamos donde I = 1
0000114C                           162      
0000114C  3C12                     163      MOVE.W (A2),D6         ; T0 <-- [[Xb]]
0000114E  CCFC 0002                164      MULU.W #2, D6
00001152  2646                     165      MOVEA.L D6, A3
00001154  31EB 1000 1014           166      MOVE.W EMEM(A3),ET0
0000115A  40C2                     167      MOVE.W SR, D2           ; guardamos los flags despues de la op.
0000115C  5252                     168      ADD.W #1, (A2)          ; Xb <-- [Xb] + 1   
0000115E  4EF9 00001176            169      JMP FINAL_LOIP
00001164                           170      
00001164                           171     I1_LOIP:
00001164  3C12                     172      MOVE.W (A2),D6         ; T0 <-- [[Xb]]
00001166  CCFC 0002                173      MULU.W #2, D6
0000116A  2646                     174      MOVEA.L D6, A3
0000116C  31EB 1000 1016           175      MOVE.W EMEM(A3),ET1
00001172  40C2                     176      MOVE.W SR, D2           ; guardamos los flags despues de la op.
00001174  5252                     177      ADD.W #1, (A2)          ; Xb <-- [Xb] + 1   
00001176                           178      
00001176                           179   FINAL_LOIP:
00001176  4244                     180      CLR.W D4                ; limpiamos D4 por si hay algo, ya que lo 
00001178  4EB9 00001490            181      JSR FLAGS_NZ            ; necesitaremos D4 para actualizar los flags N y Z
0000117E                           182      
0000117E  6000 FEAA                183      BRA FETCH
00001182                           184  
00001182                           185  *--------------------------------------------------
00001182                           186  ESTIP:                      ; [Xb] <-- [Ti], Xb <-- [Xb] + 1
00001182  3A38 1010                187      MOVE.W EIR, D5          ; metemos la instr. en D5
00001186  4EB9 000013A0            188      JSR CogerB              ; sacamaos el registro B
0000118C  344D                     189      MOVE.W A5, A2           ; guardamos el Rb en A2
0000118E                           190      
0000118E  3A38 1010                191      MOVE.W EIR, D5          ; metemos la inst. en D5
00001192  4EB9 000013BA            192      JSR CogerI              ; cogemos I
00001198  BA7C 0000                193      CMP #0, D5              ; comparamos D5(I) con 0
0000119C  6600 0018                194      BNE I1_STIP             ; si no son iguales saltamos donde I = 1
000011A0                           195      
000011A0  3C12                     196      MOVE.W (A2),D6       ; [Xb] <-- [T0]
000011A2  CCFC 0002                197      MULU.W #2, D6
000011A6  2646                     198      MOVEA.L D6, A3
000011A8  3778 1014 1000           199      MOVE.W (ET0),EMEM(A3)
000011AE  5252                     200      ADD.W #1, (A2)          ; Xb <-- [Xb] + 1  
000011B0  4EF9 000011C6            201      JMP FINAL_STIP
000011B6                           202      
000011B6                           203     I1_STIP:
000011B6  3C12                     204      MOVE.W (A2),D6       ; [Xb] <-- [T0]
000011B8  CCFC 0002                205      MULU.W #2, D6
000011BC  2646                     206      MOVEA.L D6, A3
000011BE  3778 1014 1000           207      MOVE.W (ET0),EMEM(A3)
000011C4  5252                     208      ADD.W #1, (A2)          ; Xb <-- [Xb] + 1  
000011C6                           209      
000011C6                           210   FINAL_STIP:
000011C6  4EF8 102A                211      JMP FETCH
000011CA                           212  
000011CA                           213  *--------------------------------------------------
000011CA                           214  EGOI:                       ; PC <-- M
000011CA                           215  
000011CA  3A38 1010                216      MOVE.W EIR, D5          ; movemos la instr. a D5
000011CE  4EB9 000013CE            217      JSR CogerM              ; llamamos a la subr. para coger M
000011D4  31C5 1012                218      MOVE.W D5, EPC          ; guardamos D5 en el PC del eprograma
000011D8                           219      
000011D8  6000 FE50                220      BRA FETCH
000011DC                           221                     
000011DC                           222  *--------------------------------------------------
000011DC                           223  EGOZ:                       ; si Z=1,  PC <-- M
000011DC                           224  
000011DC  3438 1024                225      MOVE.W ESR, D2          ; movemos los eflags a D2
000011E0  0802 0000                226      BTST.L #0, D2           ; comprobamos si el eflag Z es 1
000011E4  6700 0010                227      BEQ Z0                  ; si es 0 saltamos al final de la instr.
000011E8                           228      
000011E8  3A38 1010                229      MOVE.W EIR, D5          ; movemos la instr. a D5
000011EC  4EB9 000013CE            230      JSR CogerM              ; llamamos a la subr. para coger M
000011F2  31C5 1012                231      MOVE.W D5, EPC          ; guardamos D5 en el PC del eprograma
000011F6                           232  
000011F6                           233    Z0:
000011F6  6000 FE32                234      BRA FETCH    
000011FA                           235      
000011FA                           236  *--------------------------------------------------
000011FA                           237  EGON:                       ; si N=1,  PC <-- M
000011FA                           238  
000011FA  3438 1024                239      MOVE.W ESR, D2          ; movemos los eflags a D2
000011FE  0802 0001                240      BTST.L #1, D2           ; comprobamos si el eflag N es 1
00001202  6700 0010                241      BEQ N0                  ; si es 0 saltamos al final de la instr.
00001206                           242      
00001206  3A38 1010                243      MOVE.W EIR, D5          ; movemos la instr. a D5
0000120A  4EB9 000013CE            244      JSR CogerM              ; llamamos a la subr. para coger M
00001210  31C5 1012                245      MOVE.W D5, EPC          ; guardamos D5 en el PC del eprograma
00001214                           246  
00001214                           247    N0:
00001214  6000 FE14                248      BRA FETCH    
00001218                           249      
00001218                           250  *--------------------------------------------------
00001218                           251  EEXIT:                      ; Detiene la maquina
00001218  4EF9 00001580            252      JMP SIMHALT
0000121E                           253  *--------------------------------------------------
0000121E                           254  ECOPY:                      ; Rc <-- Rb
0000121E                           255  
0000121E  3A38 1010                256      MOVE.W EIR, D5          ; movemos la inst. a D5
00001222  4EB9 000013A0            257      JSR CogerB              ; cogemos B
00001228  344D                     258      MOVE.W A5, A2           ; guardamos B en A2
0000122A                           259      
0000122A  3A38 1010                260      MOVE.W EIR, D5          ; movemos de nuevo la inst. a D5,ya que se modificó
0000122E  4EB9 000013AE            261      JSR CogerC              ; cogemos C
00001234  324D                     262      MOVE.W A5, A1           ; guardamos C en A1
00001236                           263      
00001236  3292                     264      MOVE.W (A2),(A1)        ; copiamos el contenido de A2 dentro de A1
00001238                           265      
00001238  40C2                     266      MOVE.W SR, D2           ; copiamos los flags a D2
0000123A  4244                     267      CLR.W D4                ; limpiamos D4 por si hay algo, ya que lo 
0000123C  4EB9 00001490            268      JSR FLAGS_NZ            ; necesitaremos D4 para actualizar los flags N y Z
00001242                           269      
00001242  6000 FDE6                270      BRA FETCH
00001246                           271      
00001246                           272  *--------------------------------------------------
00001246                           273  EADD:                       ; Rc <-- [Rb] + [Ra]
00001246                           274  
00001246  3A38 1010                275      MOVE.W EIR, D5          ; movemos la instr. a D5
0000124A  4EB9 00001392            276      JSR CogerA              ; llamamos a la sub. de usuario para coger el valor
00001250  324D                     277      MOVE.W A5, A1           ; de A y lo movemos a A1
00001252                           278      
00001252  3A38 1010                279      MOVE.W EIR, D5
00001256  4EB9 000013A0            280      JSR CogerB              ; llamamos a la sub. de usuario para coger el valor
0000125C  344D                     281      MOVE.W A5, A2           ; de B y lo movemos a A2
0000125E                           282      
0000125E  3A38 1010                283      MOVE.W EIR, D5
00001262  4EB9 000013AE            284      JSR CogerC              ; llamamos a la sub. de usuario para coger el valor
00001268  364D                     285      MOVE.W A5, A3           ; de C y lo movemos a A3
0000126A                           286      
0000126A  4286                     287      CLR.L D6                ; preparamos D6 para poder poner el resultado
0000126C  DC51                     288      ADD.W (A1),D6           ; sumamos el contenido de A1 (A) a D6
0000126E  DC52                     289      ADD.W (A2),D6           ; sumamos el contenido de A2 (B) a D6
00001270                           290      
00001270  40C2                     291      MOVE.W SR,D2            ; guardamos los flags del 68k en D2
00001272  4244                     292      CLR.W D4                
00001274  4EB9 00001482            293      JSR Flags_CNZ           ; actualizamos los eflags
0000127A                           294      
0000127A  3686                     295      MOVE.W D6, (A3)         ; movemos el resultado a Rc
0000127C                           296      
0000127C  6000 FDAC                297      BRA FETCH
00001280                           298  *--------------------------------------------------    
00001280                           299  ESUB:                       ; Rc <-- [Rb] - [Ra]
00001280                           300  
00001280  3A38 1010                301      MOVE.W EIR, D5          ; movemos la instr. a D5
00001284  4EB9 00001392            302      JSR CogerA              ; llamamos a la sub. de usuario para coger el valor
0000128A  324D                     303      MOVE.W A5, A1           ; de A y lo movemos a A1
0000128C                           304      
0000128C  3A38 1010                305      MOVE.W EIR, D5
00001290  4EB9 000013A0            306      JSR CogerB              ; llamamos a la sub. de usuario para coger el valor
00001296  344D                     307      MOVE.W A5, A2           ; de B y lo movemos a A2
00001298                           308      
00001298  3A38 1010                309      MOVE.W EIR, D5
0000129C  4EB9 000013AE            310      JSR CogerC              ; llamamos a la sub. de usuario para coger el valor
000012A2  364D                     311      MOVE.W A5, A3           ; de C y lo movemos a A3
000012A4                           312      
000012A4  4286                     313      CLR.L D6                ; preparamos D6 para poder poner el resultado
000012A6  DC51                     314      ADD.W (A1),D6           ; sumamos el contenido de A1 (A) a D6
000012A8  4646                     315      NOT.W D6                ; negamos y sumamos 1 a A para hacer una resta
000012AA  5246                     316      ADDQ.W #1, D6
000012AC  DC52                     317      ADD.W (A2),D6           ; B + (-A)
000012AE                           318  
000012AE  40C2                     319      MOVE.W SR,D2            ; guardamos los flags del 68k en D2
000012B0  4244                     320      CLR.W D4                ; limpiamos D4
000012B2  4EB9 00001482            321      JSR Flags_CNZ           ; actualizamos los eflags
000012B8                           322      
000012B8  3686                     323      MOVE.W D6, (A3)         ; movemos el resultado a Rc
000012BA                           324      
000012BA  6000 FD6E                325      BRA FETCH
000012BE                           326  *--------------------------------------------------    
000012BE                           327  EAND:                       ; Rc <-- [Rb] and [Ra]
000012BE                           328  
000012BE  3A38 1010                329      MOVE.W EIR, D5          ; movemos la instr. a D5
000012C2  4EB9 00001392            330      JSR CogerA              ; llamamos a la sub. de usuario para coger el valor
000012C8  324D                     331      MOVE.W A5, A1           ; de A y lo movemos a A1
000012CA                           332      
000012CA  3A38 1010                333      MOVE.W EIR, D5
000012CE  4EB9 000013A0            334      JSR CogerB              ; llamamos a la sub. de usuario para coger el valor
000012D4  344D                     335      MOVE.W A5, A2           ; de B y lo movemos a A2
000012D6                           336      
000012D6  3A38 1010                337      MOVE.W EIR, D5
000012DA  4EB9 000013AE            338      JSR CogerC              ; llamamos a la sub. de usuario para coger el valor
000012E0  364D                     339      MOVE.W A5, A3           ; de C y lo movemos a A3
000012E2                           340  
000012E2  3C11                     341      MOVE.W (A1),D6          ; movemos A y B a los registros de dat.
000012E4  3E12                     342      MOVE.W (A2),D7
000012E6  CC47                     343      AND.W   D7 ,D6          ; A and B
000012E8                           344      
000012E8  40C2                     345      MOVE.W SR,D2            ; guardamos los flags del 68k en D2
000012EA  4244                     346      CLR.W D4                ; limpiamos D4 
000012EC  4EB9 00001490            347      JSR Flags_NZ            ; actualizamos los eflags
000012F2                           348      
000012F2  3686                     349      MOVE.W D6, (A3)         ; movemos el resultado a Rc
000012F4                           350      
000012F4  6000 FD34                351      BRA FETCH
000012F8                           352  *--------------------------------------------------
000012F8                           353  ESET:                       ; Rc <-- k (ext. signo)
000012F8  3A38 1010                354      MOVE.W EIR, D5          ; movemos la instr. a D5
000012FC  4EB9 000013AE            355      JSR CogerC              ; llamamos a la sub. de usuario para coger el valor
00001302  364D                     356      MOVE.W A5, A3           ; de C y lo movemos a A3
00001304                           357      
00001304  3A38 1010                358      MOVE.W EIR, D5          ; movemos la instr. a D5
00001308  4EB9 000013D6            359      JSR CogerK              ; cogemos k (dentro se realiza la ext. de signo)
0000130E  3C05                     360      MOVE.W D5, D6           ; guardamos k en D6
00001310                           361      
00001310  3686                     362      MOVE.W D6,(A3)          ; guardamos D6 (k) dentro de A3 (C)
00001312                           363      
00001312  40C2                     364      MOVE.W SR,D2            ; guardamos los flags del 68k en D2
00001314  4244                     365      CLR.W D4                ; limpiamos D4 por si hay algo, ya que lo 
00001316  4EB9 00001490            366      JSR FLAGS_NZ            ; necesitaremos D4 para actualizar los flags N y Z
0000131C                           367  
0000131C  6000 FD0C                368      BRA FETCH
00001320                           369  
00001320                           370  *--------------------------------------------------
00001320                           371  EADQ:                       ; Rc <-- [Rc] + k (ext. signo)
00001320  3A38 1010                372      MOVE.W EIR, D5          ; movemos la instr. a D5
00001324  4EB9 000013AE            373      JSR CogerC              ; llamamos a la sub. de usuario para coger el valor
0000132A  364D                     374      MOVE.W A5, A3           ; de C y lo movemos a A3
0000132C                           375      
0000132C  3A38 1010                376      MOVE.W EIR, D5          ; movemos la instr. a D5
00001330  4EB9 000013D6            377      JSR CogerK              ; cogemos k (dentro se realiza la ext. de signo)
00001336  3C05                     378      MOVE.W D5, D6           ; guardamos k en D6
00001338                           379      
00001338  DD53                     380      ADD.W D6,(A3)           ; sumamos D6 (k) con A3(C) y lo guardamos en A3(C)
0000133A                           381      
0000133A  40C2                     382      MOVE.W SR,D2            ; guardamos los flags del 68k en D2
0000133C  4244                     383      CLR.W D4                ; limpiamos D4 por si hay algo, ya que lo 
0000133E  4EB9 00001482            384      JSR FLAGS_CNZ           ; necesitaremos D4 para actualizar todos los eflags
00001344                           385  
00001344  6000 FCE4                386      BRA FETCH
00001348                           387  *--------------------------------------------------
00001348                           388  ELSH:                       ; si n=0 => Rb <-- [Rb] left shift p
00001348                           389                              ; si n=1 => Rb <-- [Rb] right shift p
00001348  3A38 1010                390      MOVE.W EIR, D5          ; movemos la inst. a D5
0000134C  4EB9 000013A0            391      JSR CogerB              ; cogemos el registro B
00001352  344D                     392      MOVE.W A5, A2           ; guardamos el Rb en A2
00001354  3E12                     393      MOVE.W (A2),D7          ; movemos el contenido de A2(B) a un registro
00001356                           394                              ; temporal
00001356                           395      
00001356  3A38 1010                396      MOVE.W EIR, D5          ; movemos la inst. a D5
0000135A  4EB9 000013C6            397      JSR CogerP              ; cogemos P
00001360  3C05                     398      MOVE.W D5, D6           ; guardamos D5(P) en D6
00001362                           399  
00001362  3A38 1010                400      MOVE.W EIR, D5          ; movemos la intsrucción a D5
00001366  4EB9 000013C0            401      JSR CogerN              ; cogemos el valor de N
0000136C  BA7C 0000                402      CMP #0, D5              ; comparamos 0 con N
00001370  6600 000E                403      BNE RShift              ; si N es 1 saltamos a right shift
00001374                           404      
00001374  ED6F                     405      LSL.W D6 , D7           ; n=0, por tanto hacemos un LSL con desp. D6(P)
00001376  40C2                     406      MOVE.W SR, D2           ; guardamos los flags después de la operación
00001378  3487                     407      MOVE.W D7, (A2)           ; guardamos el resultado en A2(B)
0000137A  4EF9 00001386            408      JMP FINAL_LSH           ; saltamos al final
00001380                           409      
00001380                           410     RShift:
00001380  EC6F                     411      LSR.W D6, D7            ; n=1, por tanto hacemos un LSR con desp. D6(P)
00001382  40C2                     412      MOVE.W SR, D2           ; guardamos los flags 
00001384  3447                     413      MOVE.W D7, A2           ; guardamos el resultado en A2(B)
00001386                           414      
00001386                           415   FINAL_LSH:
00001386  4244                     416      CLR.W D4                ; limpiamos D4 porque lo utilizamos para actualizar
00001388  4EB9 00001482            417      JSR FLAGS_CNZ           ; los flags CNZ
0000138E                           418      
0000138E  6000 FC9A                419      BRA FETCH
00001392                           420      
00001392                           421  *--------------------------------------------------
00001392                           422      ;--- FEXEC: FIN EJECUCION
00001392                           423      
00001392                           424      
00001392                           425  
00001392                           426      ;--- ISUBR: INICIO SUBRUTINAS
00001392                           427          ;*** Aqui debeis incluir las subrutinas que necesite vuestra solucion
00001392                           428          ;*** SALVO DECOD, que va en la siguiente seccion
00001392                           429  
00001392                           430              ; ESCRIBID VUESTRO CODIGO AQUI
00001392                           431              
00001392                           432  CogerA:
00001392  E08D                     433      LSR.L #8,D5             ; movemos D5 8 posiciones a la derecha
00001394  CA7C 0007                434      AND.W #$0007,D5         ; con una máscara, cogemos el valor de A (aaa)
00001398                           435      
00001398  4EB9 000013E0            436      JSR REGISTROS           ; miramos a qué registro se corresponde
0000139E                           437      
0000139E  4E75                     438      RTS
000013A0                           439      
000013A0                           440      
000013A0                           441  CogerB:
000013A0  E88D                     442      LSR.L #4,D5             ; movemos D5 4 posiciones a la derecha
000013A2  CA7C 0007                443      AND.W #$0007,D5         ; con una máscara, cogemos el valor de B (bbb)
000013A6                           444      
000013A6  4EB9 000013E0            445      JSR REGISTROS           ; miramos a qué registro se corresponde
000013AC                           446      
000013AC  4E75                     447      RTS
000013AE                           448  
000013AE                           449  
000013AE                           450  CogerC:
000013AE  CA7C 0007                451      AND.W #$0007,D5         ; con una máscara, cogemos el valor de C (ccc)
000013B2                           452  
000013B2  4EB9 000013E0            453      JSR REGISTROS           ; miramos a qué registro se corresponde
000013B8                           454      
000013B8  4E75                     455      RTS
000013BA                           456     
000013BA                           457  CogerI:
000013BA  CA7C 0001                458      AND.W #0001,D5          ; con una máscara, cogemos el valor de I
000013BE                           459      
000013BE  4E75                     460      RTS
000013C0                           461      
000013C0                           462  CogerN:
000013C0  CA7C 0001                463      AND.W #0001,D5          ; con una máscara, cogemos el valor de N
000013C4                           464      
000013C4  4E75                     465      RTS
000013C6                           466      
000013C6                           467  CogerP:
000013C6  E08D                     468      LSR.L #8,D5             ; movemos D5 8 posiciones a la derecha
000013C8  CA7C 0007                469      AND.W #0007,D5          ; con una máscara, cogemos el valor de P (ppp)
000013CC                           470      
000013CC  4E75                     471      RTS
000013CE                           472      
000013CE                           473  CogerM:
000013CE  E28D                     474      LSR.L #1,D5             ; movemos D5 4 posiciones a la derecha
000013D0  CA7C 00FF                475      AND.W #$00FF,D5         ; con una máscara, cogemos el valor de M (mmmmmmmm)
000013D4                           476      
000013D4  4E75                     477      RTS
000013D6                           478     
000013D6                           479  CogerK:
000013D6  E68D                     480      LSR.L #3,D5             ; movemos D5 3 posiciones a la derecha
000013D8  CA3C 00FF                481      AND.B #$00FF,D5         ; con una máscara, cogemos el valor de K (kkkkkkkk)
000013DC  4885                     482      EXT.W D5                ; hacemos una extensión de signo (byte -> word)
000013DE                           483      
000013DE  4E75                     484      RTS
000013E0                           485  
000013E0                           486  *--------------------------------------
000013E0                           487  
000013E0                           488  REGISTROS:
000013E0  0805 0002                489      BTST.L #2,D5            ; miramos el tercer bit del registro
000013E4  6600 0026                490      BNE REGISTROS_1XX       ; si no es 0, saltamos para mirar el registro 1XX
000013E8                           491      
000013E8                           492     ;0XX
000013E8  0805 0001                493      BTST.L #1,D5            ; miramos el segundo bit del registro
000013EC  6600 0010                494      BNE REGISTROS_01X       ; si no es 0, saltamos para mirar el registro 01X
000013F0                           495      
000013F0                           496          ;00X
000013F0  0805 0000                497           BTST.L #0,D5       ; miramos el primer bit del registro
000013F4  6700 003A                498           BEQ REGISTRO_T0    ; si es 0, el registro es B0
000013F8  4EF9 0000143A            499           JMP REGISTRO_T1    ; si es 0, el registro es B1
000013FE                           500      
000013FE                           501          REGISTROS_01X:
000013FE  0805 0000                502           BTST.L #0,D5       ; miramos el primer bit del registro
00001402  6700 0040                503           BEQ REGISTRO_X2    ; si es 0, el registro es R2
00001406  4EF9 0000144E            504           JMP REGISTRO_X3    ; si es 0, el registro es R3
0000140C                           505      
0000140C                           506     REGISTROS_1XX:
0000140C  0805 0001                507      BTST.L #1,D5            ; miramos el segundo bit del registro
00001410  6600 0010                508      BNE REGISTROS_11X       ; si no es 0, saltamos para mirar el registro 11X
00001414                           509      
00001414                           510          ;10X
00001414  0805 0000                511           BTST.L #0,D5       ; miramos el primer bit del registro
00001418  6700 003E                512           BEQ REGISTRO_X4    ; si es 0, el registro es R4
0000141C  4EF9 00001462            513           JMP REGISTRO_X5    ; si es 0, el registro es R5
00001422                           514      
00001422                           515          REGISTROS_11X:
00001422  0805 0000                516           BTST.L #0,D5       ; miramos el primer bit del registro
00001426  6700 0044                517           BEQ REGISTRO_X6    ; si es 0, el registro es T6
0000142A  4EF9 00001476            518           JMP REGISTRO_X7    ; si es 0, el registro es T7
00001430                           519      
00001430                           520  
00001430                           521    ; A partir de aquí guardamos las direcciones y salimos de la subrutina 
00001430                           522     REGISTRO_T0:
00001430  4BF8 1014                523      LEA.L ET0,A5            ; guardamos el contenido de ET0 en A5
00001434  4EF9 00001480            524      JMP FIN_REGISTROS       ; saltamos al final de la subrutina de registros
0000143A                           525      
0000143A                           526     REGISTRO_T1:
0000143A  4BF8 1016                527      LEA.L ET1,A5            ; guardamos el contenido de ET1 en A5
0000143E  4EF9 00001480            528      JMP FIN_REGISTROS       ; saltamos al final de la subrutina de registros
00001444                           529      
00001444                           530     REGISTRO_X2:
00001444  4BF8 1018                531      LEA.L EX2,A5            ; guardamos el contenido de EX2 en A5
00001448  4EF9 00001480            532      JMP FIN_REGISTROS       ; saltamos al final de la subrutina de registros
0000144E                           533      
0000144E                           534     REGISTRO_X3:
0000144E  4BF8 101A                535      LEA.L EX3,A5            ; guardamos el contenido de EX3 en A5
00001452  4EF9 00001480            536      JMP FIN_REGISTROS       ; saltamos al final de la subrutina de registros
00001458                           537      
00001458                           538     REGISTRO_X4:
00001458  4BF8 101C                539      LEA.L EX4,A5            ; guardamos el contenido de EX4 en A5
0000145C  4EF9 00001480            540      JMP FIN_REGISTROS       ; saltamos al final de la subrutina de registros
00001462                           541      
00001462                           542     REGISTRO_X5:
00001462  4BF8 101E                543      LEA.L EX5,A5            ; guardamos el contenido de EX5 en A5
00001466  4EF9 00001480            544      JMP FIN_REGISTROS       ; saltamos al final de la subrutina de registros
0000146C                           545      
0000146C                           546     REGISTRO_X6:
0000146C  4BF8 1020                547      LEA.L EX6,A5            ; guardamos el contenido de EX6 en A5
00001470  4EF9 00001480            548      JMP FIN_REGISTROS       ; saltamos al final de la subrutina de registros
00001476                           549      
00001476                           550     REGISTRO_X7:
00001476  4BF8 1022                551      LEA.L EX7,A5            ; guardamos el contenido de EX7 en A5
0000147A  4EF9 00001480            552      JMP FIN_REGISTROS       ; saltamos al final de la subrutina de registros
00001480                           553      
00001480                           554     FIN_REGISTROS: 
00001480  4E75                     555      RTS
00001482                           556  *--------------------------------------
00001482                           557  ; Flags 68k = NZVC, FLAGS HAL9000 = 0CNZ  
00001482                           558  
00001482                           559  FLAGS_CNZ:
00001482  3602                     560      MOVE D2,D3              ; copiamos los flags para poder manipularlos
00001484  0803 0000                561      BTST.L #0,D3            ; miramos C
00001488  6700 0006                562      BEQ FLAGS_NZ            ; si C es 0, saltamos a mirar el flag Z
0000148C                           563      
0000148C  08C4 0002                564      BSET.L #2,D4              ; si no es 0, pondremos a 1 el valor de C en D4
00001490                           565      
00001490                           566  *--------------------------------------    
00001490                           567  FLAGS_NZ:
00001490  3602                     568      MOVE.W D2,D3            ; copiamos los flags para poder manipularlos
00001492  0803 0003                569      BTST.L #3,D3            ; miramos N
00001496  6700 0006                570      BEQ FLAG_Z              ; si N es 0, saltamos a mirar el siguiente flag
0000149A                           571      
0000149A  08C4 0001                572      BSET.L #1,D4            ; si no es 0, pondremos a 1 el valor de N en D4
0000149E                           573      
0000149E                           574     FLAG_Z:
0000149E  3602                     575      MOVE.W D2,D3            ; copiamos los flags para poder manipularlos
000014A0  0803 0002                576      BTST.L #2,D3            ; miramos Z
000014A4  6700 0006                577      BEQ FINAL_FLAGS         ; si Z es 0, saltamos al final de los flags
000014A8                           578      
000014A8  08C4 0000                579      BSET.L #0,D4            ; si no es 0, pondremos a 1 el valor de Z en D4
000014AC                           580      
000014AC                           581     FINAL_FLAGS:
000014AC  31C4 1024                582      MOVE.W D4,ESR           ; movemos D4 (flags finales) a ESR, los eflags
000014B0  4E75                     583      RTS
000014B2                           584          
000014B2                           585          
000014B2                           586      ;--- FSUBR: FIN SUBRUTINAS
000014B2                           587      
000014B2                           588      
000014B2                           589  
000014B2                           590      ;--- IDECOD: INICIO DECOD
000014B2                           591          ;*** Tras la etiqueta DECOD, debeis implementar la subrutina de 
000014B2                           592          ;*** decodificacion, que debera ser de libreria, siguiendo la interfaz
000014B2                           593          ;*** especificada en el enunciado
000014B2                           594  DECOD:
000014B2                           595              ; ESCRIBID VUESTRO CODIGO AQUI
000014B2                           596              
000014B2  3F00                     597      MOVE.W D0,-(A7)         ; guardamos D0 en la pila
000014B4  3F01                     598      MOVE.W D1,-(A7)         ; guardamos D1 en la pila
000014B6  302F 0008                599      MOVE.W 8(A7),D0         ; la instrucción que hemos guardado la pasamos a D0
000014BA                           600  
000014BA  323C 0000                601      MOVE.W #0, D1           ; D1 contiene el id de la instrucción
000014BE  0800 000F                602      BTST.L #15, D0          ; miramos el bit 16º de la instr.
000014C2  6600 0050                603      BNE DECOD_1XXX          ; si no es 0, saltamos a para la instr. 1XXX
000014C6                           604      
000014C6                           605      ;0XXX
000014C6  0800 000E                606      BTST.L #14, D0          ; miramos el bit 15º de la instr.
000014CA  6600 0028                607      BNE DECOD_01XX          ; si no es 0, saltamos a para la instr. 01XX
000014CE                           608  
000014CE                           609          ;00XX
000014CE  0800 000D                610          BTST.L #13, D0      ; miramos el bit 14º de la instr.
000014D2  6600 0010                611          BNE DECOD_001X      ; si no es 0, saltamos a para la instr. 001X
000014D6                           612          
000014D6                           613              ;000X
000014D6  0800 000C                614              BTST.L #12, D0  ; miramos el bit 13º de la instr.
000014DA  6600 0098                615              BNE FINAL_AUX   ; si no es 0, saltamos a final aux para sumar 1
000014DE  4EF9 00001576            616              JMP FINAL       ; si es 0, saltamos al final
000014E4                           617              
000014E4                           618            DECOD_001X:
000014E4  5441                     619              ADDQ.W #2, D1   ; sumamos 2 al id de la instr.
000014E6  0800 000C                620              BTST.L #12, D0  ; miramos el bit 13º de la instr.  
000014EA  6600 0088                621              BNE FINAL_AUX   ; si no es 0, saltamos a final aux para sumar 1
000014EE  4EF9 00001576            622              JMP FINAL       ; si es 0, saltamos al final
000014F4                           623           
000014F4                           624        DECOD_01XX:
000014F4  5841                     625          ADDQ.W #4, D1       ; sumamos 4 al id de la instr.
000014F6  0800 000D                626          BTST.L #13, D0      ; miramos el bit 14º de la instr.
000014FA  6600 0010                627          BNE DECOD_0110      ; si no es 0, saltamos a la única otra 
000014FE                           628                              ; posibilidad que es 0110
000014FE                           629             ;010X
000014FE  0800 000C                630             BTST.L #12, D0   ; miramos el bit 13º de la instr.
00001502  6600 0070                631             BNE FINAL_AUX    ; si no es 0, saltamos a final aux para sumar 1
00001506  4EF9 00001576            632             JMP FINAL        ; si es 0, saltamos directamente al final
0000150C                           633        
0000150C                           634        DECOD_0110:
0000150C  5C41                     635          ADDQ.W #6, D1       ; sumamos 6 directamente porque solo hay 1 instr.
0000150E  4EF9 00001576            636          JMP FINAL           ; que empiece por 011
00001514                           637          
00001514                           638    DECOD_1XXX:
00001514  5E41                     639      ADDQ.W #7, D1           ; id = 7
00001516  0800 000E                640      BTST.L #14, D0          ; miramos el bit 15º de la instr.
0000151A  6600 0008                641      BNE DECOD_11XXX         ; si no es 0, saltamos a la instr. 10XXX
0000151E  4EF9 00001576            642      JMP FINAL               ; como la única instr. con 10 sumamos el id
00001524                           643                              ; y saltamos directamente al final
00001524                           644          
00001524                           645        
00001524                           646    DECOD_11XXX:
00001524  0800 000D                647      BTST.L #13, D0          ; miramos el bit 14º 
00001528  6600 002A                648      BNE DECOD_111XX         ; si no es 0, saltamos a 111XX
0000152C                           649      
0000152C                           650          ;110XX
0000152C  0800 000C                651          BTST.L #12, D0      ; miramos el bit 13º
00001530  6600 0012                652          BNE DECOD_1101X
00001534                           653          
00001534                           654              ;1100X
00001534  5241                     655              ADDQ.W #1, D1   ; id = 8
00001536  0800 000B                656              BTST.L #11, D0  ; miramos el bit 12º 
0000153A  6600 0038                657              BNE FINAL_AUX   ; si es 1, saltamos al final aux para sumar 1
0000153E  4EF9 00001576            658              JMP FINAL       ; si es 0, saltamos directamente al final
00001544                           659  
00001544                           660  
00001544                           661             DECOD_1101X:
00001544  5641                     662              ADDQ.W #3, D1   ; id = 10
00001546  0800 000B                663              BTST.L #11, D0  ; miramos el bit 12º
0000154A  6600 0028                664              BNE FINAL_AUX   ; si es 1, saltamos al final aux para sumar 1
0000154E  4EF9 00001576            665              JMP FINAL       ; si es 0, saltamos directamente al final
00001554                           666        
00001554                           667        DECOD_111XX:
00001554  5A41                     668          ADDQ.W #5, D1       ; id = 12
00001556  0800 000C                669          BTST.L #12, D0      ; miramos el bit 13º
0000155A  6600 0010                670          BNE DECOD_11110     ; si es 1, saltamos a 11110
0000155E                           671          
0000155E                           672              ;11100
0000155E  0800 000B                673              BTST.L #11, D0  ; miramos el bit 12º
00001562  6600 0010                674              BNE FINAL_AUX   ; si es 1, sumamos 1 al id
00001566  4EF9 00001576            675              JMP FINAL       ; si es 0, saltamos al final
0000156C                           676              
0000156C                           677            DECOD_11110:
0000156C  5441                     678              ADDQ.W #2, D1   ; id = 14
0000156E  4EF9 00001576            679              JMP FINAL
00001574                           680  
00001574                           681     FINAL_AUX:
00001574  5241                     682      ADDQ.W #1,D1            ; sumamos 1 al id
00001576                           683      
00001576                           684     FINAL: 
00001576  3F41 000A                685      MOVE.W D1,10(A7)        ; guardamos el id en la pila
0000157A  321F                     686      MOVE.W (A7)+,D1         ; sacamos D1 de la pila
0000157C  301F                     687      MOVE.W (A7)+,D0         ; sacamos D0 de la pila
0000157E                           688      
0000157E  4E75                     689      RTS
00001580                           690  
00001580                           691  
00001580                           692      ;--- FDECOD: FIN DECOD
00001580                           693      
00001580                           694  SIMHALT:
00001580  FFFF FFFF                695      SIMHALT                 ; detiene la máquina
00001584                           696      END    START

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
COGERA              1392
COGERB              13A0
COGERC              13AE
COGERI              13BA
COGERK              13D6
COGERM              13CE
COGERN              13C0
COGERP              13C6
DECOD               14B2
DECOD_001X          14E4
DECOD_0110          150C
DECOD_01XX          14F4
DECOD_1101X         1544
DECOD_11110         156C
DECOD_111XX         1554
DECOD_11XXX         1524
DECOD_1XXX          1514
EADD                1246
EADQ                1320
EAND                12BE
ECOPY               121E
EEXIT               1218
EGOI                11CA
EGON                11FA
EGOZ                11DC
EIR                 1010
ELOA                10B6
ELOIP               112E
ELSH                1348
EMEM                1000
EPC                 1012
ESET                12F8
ESR                 1024
ESTIP               1182
ESTO                10FA
ESUB                1280
ET0                 1014
ET1                 1016
EX2                 1018
EX3                 101A
EX4                 101C
EX5                 101E
EX6                 1020
EX7                 1022
FETCH               102A
FINAL               1576
FINAL_AUX           1574
FINAL_FLAGS         14AC
FINAL_LOAD          10EE
FINAL_LOIP          1176
FINAL_LSH           1386
FINAL_STIP          11C6
FINAL_STORE         112A
FIN_REGISTROS       1480
FLAGS_CNZ           1482
FLAGS_NZ            1490
FLAG_Z              149E
I1_LOAD             10E8
I1_LOIP             1164
I1_STIP             11B6
I1_STORE            1126
IBREDECOD           1040
JMPLIST             105C
N0                  1214
REGISTROS           13E0
REGISTROS_01X       13FE
REGISTROS_11X       1422
REGISTROS_1XX       140C
REGISTRO_T0         1430
REGISTRO_T1         143A
REGISTRO_X2         1444
REGISTRO_X3         144E
REGISTRO_X4         1458
REGISTRO_X5         1462
REGISTRO_X6         146C
REGISTRO_X7         1476
RSHIFT              1380
SIMHALT             1580
START               1026
Z0                  11F6
